{"ast":null,"code":"var fn = new Intl.Collator(0, {\n  numeric: 1\n}).compare;\nfunction semiver(a, b, bool) {\n  a = a.split(\".\");\n  b = b.split(\".\");\n  return fn(a[0], b[0]) || fn(a[1], b[1]) || (b[2] = b.slice(2).join(\".\"), bool = /[.-]/.test(a[2] = a.slice(2).join(\".\")), bool == /[.-]/.test(b[2]) ? fn(a[2], b[2]) : bool ? -1 : 1);\n}\nfunction resolve_root(base_url, root_path, prioritize_base) {\n  if (root_path.startsWith(\"http://\") || root_path.startsWith(\"https://\")) {\n    return prioritize_base ? base_url : root_path;\n  }\n  return base_url + root_path;\n}\nfunction determine_protocol(endpoint) {\n  if (endpoint.startsWith(\"http\")) {\n    const {\n      protocol,\n      host\n    } = new URL(endpoint);\n    if (host.endsWith(\"hf.space\")) {\n      return {\n        ws_protocol: \"wss\",\n        host,\n        http_protocol: protocol\n      };\n    }\n    return {\n      ws_protocol: protocol === \"https:\" ? \"wss\" : \"ws\",\n      http_protocol: protocol,\n      host\n    };\n  } else if (endpoint.startsWith(\"file:\")) {\n    return {\n      ws_protocol: \"ws\",\n      http_protocol: \"http:\",\n      host: \"lite.local\"\n      // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.\n    };\n  }\n\n  return {\n    ws_protocol: \"wss\",\n    http_protocol: \"https:\",\n    host: endpoint\n  };\n}\nconst RE_SPACE_NAME = /^[^\\/]*\\/[^\\/]*$/;\nconst RE_SPACE_DOMAIN = /.*hf\\.space\\/{0,1}$/;\nasync function process_endpoint(app_reference, token) {\n  const headers = {};\n  if (token) {\n    headers.Authorization = `Bearer ${token}`;\n  }\n  const _app_reference = app_reference.trim();\n  if (RE_SPACE_NAME.test(_app_reference)) {\n    try {\n      const res = await fetch(`https://huggingface.co/api/spaces/${_app_reference}/host`, {\n        headers\n      });\n      if (res.status !== 200) throw new Error(\"Space metadata could not be loaded.\");\n      const _host = (await res.json()).host;\n      return {\n        space_id: app_reference,\n        ...determine_protocol(_host)\n      };\n    } catch (e) {\n      throw new Error(\"Space metadata could not be loaded.\" + e.message);\n    }\n  }\n  if (RE_SPACE_DOMAIN.test(_app_reference)) {\n    const {\n      ws_protocol,\n      http_protocol,\n      host\n    } = determine_protocol(_app_reference);\n    return {\n      space_id: host.replace(\".hf.space\", \"\"),\n      ws_protocol,\n      http_protocol,\n      host\n    };\n  }\n  return {\n    space_id: false,\n    ...determine_protocol(_app_reference)\n  };\n}\nfunction map_names_to_ids(fns) {\n  let apis = {};\n  fns.forEach(({\n    api_name\n  }, i) => {\n    if (api_name) apis[api_name] = i;\n  });\n  return apis;\n}\nconst RE_DISABLED_DISCUSSION = /^(?=[^]*\\b[dD]iscussions{0,1}\\b)(?=[^]*\\b[dD]isabled\\b)[^]*$/;\nasync function discussions_enabled(space_id) {\n  try {\n    const r = await fetch(`https://huggingface.co/api/spaces/${space_id}/discussions`, {\n      method: \"HEAD\"\n    });\n    const error = r.headers.get(\"x-error-message\");\n    if (error && RE_DISABLED_DISCUSSION.test(error)) return false;\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nasync function get_space_hardware(space_id, token) {\n  const headers = {};\n  if (token) {\n    headers.Authorization = `Bearer ${token}`;\n  }\n  try {\n    const res = await fetch(`https://huggingface.co/api/spaces/${space_id}/runtime`, {\n      headers\n    });\n    if (res.status !== 200) throw new Error(\"Space hardware could not be obtained.\");\n    const {\n      hardware\n    } = await res.json();\n    return hardware;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nasync function set_space_hardware(space_id, new_hardware, token) {\n  const headers = {};\n  if (token) {\n    headers.Authorization = `Bearer ${token}`;\n  }\n  try {\n    const res = await fetch(`https://huggingface.co/api/spaces/${space_id}/hardware`, {\n      headers,\n      body: JSON.stringify(new_hardware)\n    });\n    if (res.status !== 200) throw new Error(\"Space hardware could not be set. Please ensure the space hardware provided is valid and that a Hugging Face token is passed in.\");\n    const {\n      hardware\n    } = await res.json();\n    return hardware;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nasync function set_space_timeout(space_id, timeout, token) {\n  const headers = {};\n  if (token) {\n    headers.Authorization = `Bearer ${token}`;\n  }\n  try {\n    const res = await fetch(`https://huggingface.co/api/spaces/${space_id}/hardware`, {\n      headers,\n      body: JSON.stringify({\n        seconds: timeout\n      })\n    });\n    if (res.status !== 200) throw new Error(\"Space hardware could not be set. Please ensure the space hardware provided is valid and that a Hugging Face token is passed in.\");\n    const {\n      hardware\n    } = await res.json();\n    return hardware;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nconst hardware_types = [\"cpu-basic\", \"cpu-upgrade\", \"t4-small\", \"t4-medium\", \"a10g-small\", \"a10g-large\", \"a100-large\"];\nfunction normalise_file(file, server_url, proxy_url) {\n  if (file == null) {\n    return null;\n  }\n  if (Array.isArray(file)) {\n    const normalized_file = [];\n    for (const x of file) {\n      if (x == null) {\n        normalized_file.push(null);\n      } else {\n        normalized_file.push(normalise_file(x, server_url, proxy_url));\n      }\n    }\n    return normalized_file;\n  }\n  if (file.is_stream) {\n    if (proxy_url == null) {\n      return new FileData({\n        ...file,\n        url: server_url + \"/stream/\" + file.path\n      });\n    }\n    return new FileData({\n      ...file,\n      url: \"/proxy=\" + proxy_url + \"stream/\" + file.path\n    });\n  }\n  return new FileData({\n    ...file,\n    url: get_fetchable_url_or_file(file.path, server_url, proxy_url)\n  });\n}\nfunction is_url(str) {\n  try {\n    const url = new URL(str);\n    return url.protocol === \"http:\" || url.protocol === \"https:\";\n  } catch {\n    return false;\n  }\n}\nfunction get_fetchable_url_or_file(path, server_url, proxy_url) {\n  if (path == null) {\n    return proxy_url ? `/proxy=${proxy_url}file=` : `${server_url}/file=`;\n  }\n  if (is_url(path)) {\n    return path;\n  }\n  return proxy_url ? `/proxy=${proxy_url}file=${path}` : `${server_url}/file=${path}`;\n}\nasync function upload(file_data, root, upload_id, upload_fn = upload_files) {\n  let files = (Array.isArray(file_data) ? file_data : [file_data]).map(file_data2 => file_data2.blob);\n  return await Promise.all(await upload_fn(root, files, void 0, upload_id).then(async response => {\n    if (response.error) {\n      throw new Error(response.error);\n    } else {\n      if (response.files) {\n        return response.files.map((f, i) => {\n          const file = new FileData({\n            ...file_data[i],\n            path: f\n          });\n          return normalise_file(file, root, null);\n        });\n      }\n      return [];\n    }\n  }));\n}\nasync function prepare_files(files, is_stream) {\n  return files.map((f, i) => new FileData({\n    path: f.name,\n    orig_name: f.name,\n    blob: f,\n    size: f.size,\n    mime_type: f.type,\n    is_stream\n  }));\n}\nclass FileData {\n  constructor({\n    path,\n    url,\n    orig_name,\n    size,\n    blob,\n    is_stream,\n    mime_type,\n    alt_text\n  }) {\n    this.path = path;\n    this.url = url;\n    this.orig_name = orig_name;\n    this.size = size;\n    this.blob = url ? void 0 : blob;\n    this.is_stream = is_stream;\n    this.mime_type = mime_type;\n    this.alt_text = alt_text;\n  }\n}\nconst QUEUE_FULL_MSG = \"This application is too busy. Keep trying!\";\nconst BROKEN_CONNECTION_MSG = \"Connection errored out.\";\nlet NodeBlob;\nasync function duplicate(app_reference, options) {\n  const {\n    hf_token,\n    private: _private,\n    hardware,\n    timeout\n  } = options;\n  if (hardware && !hardware_types.includes(hardware)) {\n    throw new Error(`Invalid hardware type provided. Valid types are: ${hardware_types.map(v => `\"${v}\"`).join(\",\")}.`);\n  }\n  const headers = {\n    Authorization: `Bearer ${hf_token}`\n  };\n  const user = (await (await fetch(`https://huggingface.co/api/whoami-v2`, {\n    headers\n  })).json()).name;\n  const space_name = app_reference.split(\"/\")[1];\n  const body = {\n    repository: `${user}/${space_name}`\n  };\n  if (_private) {\n    body.private = true;\n  }\n  try {\n    const response = await fetch(`https://huggingface.co/api/spaces/${app_reference}/duplicate`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      body: JSON.stringify(body)\n    });\n    if (response.status === 409) {\n      return client(`${user}/${space_name}`, options);\n    }\n    const duplicated_space = await response.json();\n    let original_hardware;\n    if (!hardware) {\n      original_hardware = await get_space_hardware(app_reference, hf_token);\n    }\n    const requested_hardware = hardware || original_hardware || \"cpu-basic\";\n    await set_space_hardware(`${user}/${space_name}`, requested_hardware, hf_token);\n    await set_space_timeout(`${user}/${space_name}`, timeout || 300, hf_token);\n    return client(duplicated_space.url, options);\n  } catch (e) {\n    throw new Error(e);\n  }\n}\nfunction api_factory(fetch_implementation, EventSource_factory) {\n  return {\n    post_data: post_data2,\n    upload_files: upload_files2,\n    client: client2,\n    handle_blob: handle_blob2\n  };\n  async function post_data2(url, body, token) {\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if (token) {\n      headers.Authorization = `Bearer ${token}`;\n    }\n    try {\n      var response = await fetch_implementation(url, {\n        method: \"POST\",\n        body: JSON.stringify(body),\n        headers\n      });\n    } catch (e) {\n      return [{\n        error: BROKEN_CONNECTION_MSG\n      }, 500];\n    }\n    let output;\n    let status;\n    try {\n      output = await response.json();\n      status = response.status;\n    } catch (e) {\n      output = {\n        error: `Could not parse server response: ${e}`\n      };\n      status = 500;\n    }\n    return [output, status];\n  }\n  async function upload_files2(root, files, token, upload_id) {\n    const headers = {};\n    if (token) {\n      headers.Authorization = `Bearer ${token}`;\n    }\n    const chunkSize = 1e3;\n    const uploadResponses = [];\n    for (let i = 0; i < files.length; i += chunkSize) {\n      const chunk = files.slice(i, i + chunkSize);\n      const formData = new FormData();\n      chunk.forEach(file => {\n        formData.append(\"files\", file);\n      });\n      try {\n        const upload_url = upload_id ? `${root}/upload?upload_id=${upload_id}` : `${root}/upload`;\n        var response = await fetch_implementation(upload_url, {\n          method: \"POST\",\n          body: formData,\n          headers\n        });\n      } catch (e) {\n        return {\n          error: BROKEN_CONNECTION_MSG\n        };\n      }\n      const output = await response.json();\n      uploadResponses.push(...output);\n    }\n    return {\n      files: uploadResponses\n    };\n  }\n  async function client2(app_reference, options = {\n    normalise_files: true\n  }) {\n    return new Promise(async res => {\n      const {\n        status_callback,\n        hf_token,\n        normalise_files\n      } = options;\n      const return_obj = {\n        predict,\n        submit,\n        view_api,\n        component_server\n      };\n      const transform_files = normalise_files ?? true;\n      if ((typeof window === \"undefined\" || !(\"WebSocket\" in window)) && !global.Websocket) {\n        const ws = await import(\"./wrapper-6f348d45.js\");\n        NodeBlob = (await import(\"node:buffer\")).Blob;\n        global.WebSocket = ws.WebSocket;\n      }\n      const {\n        ws_protocol,\n        http_protocol,\n        host,\n        space_id\n      } = await process_endpoint(app_reference, hf_token);\n      const session_hash = Math.random().toString(36).substring(2);\n      const last_status = {};\n      let stream_open = false;\n      let pending_stream_messages = {};\n      let event_stream = null;\n      const event_callbacks = {};\n      const unclosed_events = /* @__PURE__ */new Set();\n      let config;\n      let api_map = {};\n      let jwt = false;\n      if (hf_token && space_id) {\n        jwt = await get_jwt(space_id, hf_token);\n      }\n      async function config_success(_config) {\n        config = _config;\n        api_map = map_names_to_ids((_config == null ? void 0 : _config.dependencies) || []);\n        if (config.auth_required) {\n          return {\n            config,\n            ...return_obj\n          };\n        }\n        try {\n          api = await view_api(config);\n        } catch (e) {\n          console.error(`Could not get api details: ${e.message}`);\n        }\n        return {\n          config,\n          ...return_obj\n        };\n      }\n      let api;\n      async function handle_space_sucess(status) {\n        if (status_callback) status_callback(status);\n        if (status.status === \"running\") try {\n          config = await resolve_config(fetch_implementation, `${http_protocol}//${host}`, hf_token);\n          const _config = await config_success(config);\n          res(_config);\n        } catch (e) {\n          console.error(e);\n          if (status_callback) {\n            status_callback({\n              status: \"error\",\n              message: \"Could not load this space.\",\n              load_status: \"error\",\n              detail: \"NOT_FOUND\"\n            });\n          }\n        }\n      }\n      try {\n        config = await resolve_config(fetch_implementation, `${http_protocol}//${host}`, hf_token);\n        const _config = await config_success(config);\n        res(_config);\n      } catch (e) {\n        console.error(e);\n        if (space_id) {\n          check_space_status(space_id, RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\", handle_space_sucess);\n        } else {\n          if (status_callback) status_callback({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        }\n      }\n      function predict(endpoint, data, event_data) {\n        let data_returned = false;\n        let status_complete = false;\n        let dependency;\n        if (typeof endpoint === \"number\") {\n          dependency = config.dependencies[endpoint];\n        } else {\n          const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n          dependency = config.dependencies[api_map[trimmed_endpoint]];\n        }\n        if (dependency.types.continuous) {\n          throw new Error(\"Cannot call predict on this function as it may run forever. Use submit instead\");\n        }\n        return new Promise((res2, rej) => {\n          const app = submit(endpoint, data, event_data);\n          let result;\n          app.on(\"data\", d => {\n            if (status_complete) {\n              app.destroy();\n              res2(d);\n            }\n            data_returned = true;\n            result = d;\n          }).on(\"status\", status => {\n            if (status.stage === \"error\") rej(status);\n            if (status.stage === \"complete\") {\n              status_complete = true;\n              if (data_returned) {\n                app.destroy();\n                res2(result);\n              }\n            }\n          });\n        });\n      }\n      function submit(endpoint, data, event_data, trigger_id = null) {\n        let fn_index;\n        let api_info;\n        if (typeof endpoint === \"number\") {\n          fn_index = endpoint;\n          api_info = api.unnamed_endpoints[fn_index];\n        } else {\n          const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n          fn_index = api_map[trimmed_endpoint];\n          api_info = api.named_endpoints[endpoint.trim()];\n        }\n        if (typeof fn_index !== \"number\") {\n          throw new Error(\"There is no endpoint matching that name of fn_index matching that number.\");\n        }\n        let websocket;\n        let eventSource;\n        let protocol = config.protocol ?? \"ws\";\n        const _endpoint = typeof endpoint === \"number\" ? \"/predict\" : endpoint;\n        let payload;\n        let event_id = null;\n        let complete = false;\n        const listener_map = {};\n        let url_params = \"\";\n        if (typeof window !== \"undefined\") {\n          url_params = new URLSearchParams(window.location.search).toString();\n        }\n        handle_blob2(`${config.root}`, data, api_info, hf_token).then(_payload => {\n          payload = {\n            data: _payload || [],\n            event_data,\n            fn_index,\n            trigger_id\n          };\n          if (skip_queue(fn_index, config)) {\n            fire_event({\n              type: \"status\",\n              endpoint: _endpoint,\n              stage: \"pending\",\n              queue: false,\n              fn_index,\n              time: /* @__PURE__ */new Date()\n            });\n            post_data2(`${config.root}/run${_endpoint.startsWith(\"/\") ? _endpoint : `/${_endpoint}`}${url_params ? \"?\" + url_params : \"\"}`, {\n              ...payload,\n              session_hash\n            }, hf_token).then(([output, status_code]) => {\n              const data2 = transform_files ? transform_output(output.data, api_info, config.root, config.root_url) : output.data;\n              if (status_code == 200) {\n                fire_event({\n                  type: \"data\",\n                  endpoint: _endpoint,\n                  fn_index,\n                  data: data2,\n                  time: /* @__PURE__ */new Date()\n                });\n                fire_event({\n                  type: \"status\",\n                  endpoint: _endpoint,\n                  fn_index,\n                  stage: \"complete\",\n                  eta: output.average_duration,\n                  queue: false,\n                  time: /* @__PURE__ */new Date()\n                });\n              } else {\n                fire_event({\n                  type: \"status\",\n                  stage: \"error\",\n                  endpoint: _endpoint,\n                  fn_index,\n                  message: output.error,\n                  queue: false,\n                  time: /* @__PURE__ */new Date()\n                });\n              }\n            }).catch(e => {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                message: e.message,\n                endpoint: _endpoint,\n                fn_index,\n                queue: false,\n                time: /* @__PURE__ */new Date()\n              });\n            });\n          } else if (protocol == \"ws\") {\n            fire_event({\n              type: \"status\",\n              stage: \"pending\",\n              queue: true,\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date()\n            });\n            let url = new URL(`${ws_protocol}://${resolve_root(host, config.path, true)}\n\t\t\t\t\t\t\t/queue/join${url_params ? \"?\" + url_params : \"\"}`);\n            if (jwt) {\n              url.searchParams.set(\"__sign\", jwt);\n            }\n            websocket = new WebSocket(url);\n            websocket.onclose = evt => {\n              if (!evt.wasClean) {\n                fire_event({\n                  type: \"status\",\n                  stage: \"error\",\n                  broken: true,\n                  message: BROKEN_CONNECTION_MSG,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index,\n                  time: /* @__PURE__ */new Date()\n                });\n              }\n            };\n            websocket.onmessage = function (event) {\n              const _data = JSON.parse(event.data);\n              const {\n                type,\n                status,\n                data: data2\n              } = handle_message(_data, last_status[fn_index]);\n              if (type === \"update\" && status && !complete) {\n                fire_event({\n                  type: \"status\",\n                  endpoint: _endpoint,\n                  fn_index,\n                  time: /* @__PURE__ */new Date(),\n                  ...status\n                });\n                if (status.stage === \"error\") {\n                  websocket.close();\n                }\n              } else if (type === \"hash\") {\n                websocket.send(JSON.stringify({\n                  fn_index,\n                  session_hash\n                }));\n                return;\n              } else if (type === \"data\") {\n                websocket.send(JSON.stringify({\n                  ...payload,\n                  session_hash\n                }));\n              } else if (type === \"complete\") {\n                complete = status;\n              } else if (type === \"log\") {\n                fire_event({\n                  type: \"log\",\n                  log: data2.log,\n                  level: data2.level,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n              } else if (type === \"generating\") {\n                fire_event({\n                  type: \"status\",\n                  time: /* @__PURE__ */new Date(),\n                  ...status,\n                  stage: status == null ? void 0 : status.stage,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n              }\n              if (data2) {\n                fire_event({\n                  type: \"data\",\n                  time: /* @__PURE__ */new Date(),\n                  data: transform_files ? transform_output(data2.data, api_info, config.root, config.root_url) : data2.data,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n                if (complete) {\n                  fire_event({\n                    type: \"status\",\n                    time: /* @__PURE__ */new Date(),\n                    ...complete,\n                    stage: status == null ? void 0 : status.stage,\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index\n                  });\n                  websocket.close();\n                }\n              }\n            };\n            if (semiver(config.version || \"2.0.0\", \"3.6\") < 0) {\n              addEventListener(\"open\", () => websocket.send(JSON.stringify({\n                hash: session_hash\n              })));\n            }\n          } else if (protocol == \"sse\") {\n            fire_event({\n              type: \"status\",\n              stage: \"pending\",\n              queue: true,\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date()\n            });\n            var params = new URLSearchParams({\n              fn_index: fn_index.toString(),\n              session_hash\n            }).toString();\n            let url = new URL(`${config.root}/queue/join?${url_params ? url_params + \"&\" : \"\"}${params}`);\n            eventSource = EventSource_factory(url);\n            eventSource.onmessage = async function (event) {\n              const _data = JSON.parse(event.data);\n              const {\n                type,\n                status,\n                data: data2\n              } = handle_message(_data, last_status[fn_index]);\n              if (type === \"update\" && status && !complete) {\n                fire_event({\n                  type: \"status\",\n                  endpoint: _endpoint,\n                  fn_index,\n                  time: /* @__PURE__ */new Date(),\n                  ...status\n                });\n                if (status.stage === \"error\") {\n                  eventSource.close();\n                }\n              } else if (type === \"data\") {\n                event_id = _data.event_id;\n                let [_, status2] = await post_data2(`${config.root}/queue/data`, {\n                  ...payload,\n                  session_hash,\n                  event_id\n                }, hf_token);\n                if (status2 !== 200) {\n                  fire_event({\n                    type: \"status\",\n                    stage: \"error\",\n                    message: BROKEN_CONNECTION_MSG,\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */new Date()\n                  });\n                  eventSource.close();\n                }\n              } else if (type === \"complete\") {\n                complete = status;\n              } else if (type === \"log\") {\n                fire_event({\n                  type: \"log\",\n                  log: data2.log,\n                  level: data2.level,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n              } else if (type === \"generating\") {\n                fire_event({\n                  type: \"status\",\n                  time: /* @__PURE__ */new Date(),\n                  ...status,\n                  stage: status == null ? void 0 : status.stage,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n              }\n              if (data2) {\n                fire_event({\n                  type: \"data\",\n                  time: /* @__PURE__ */new Date(),\n                  data: transform_files ? transform_output(data2.data, api_info, config.root, config.root_url) : data2.data,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n                if (complete) {\n                  fire_event({\n                    type: \"status\",\n                    time: /* @__PURE__ */new Date(),\n                    ...complete,\n                    stage: status == null ? void 0 : status.stage,\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index\n                  });\n                  eventSource.close();\n                }\n              }\n            };\n          } else if (protocol == \"sse_v1\") {\n            fire_event({\n              type: \"status\",\n              stage: \"pending\",\n              queue: true,\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date()\n            });\n            post_data2(`${config.root}/queue/join?${url_params}`, {\n              ...payload,\n              session_hash\n            }, hf_token).then(([response, status]) => {\n              if (status === 503) {\n                fire_event({\n                  type: \"status\",\n                  stage: \"error\",\n                  message: QUEUE_FULL_MSG,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index,\n                  time: /* @__PURE__ */new Date()\n                });\n              } else if (status !== 200) {\n                fire_event({\n                  type: \"status\",\n                  stage: \"error\",\n                  message: BROKEN_CONNECTION_MSG,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index,\n                  time: /* @__PURE__ */new Date()\n                });\n              } else {\n                event_id = response.event_id;\n                let callback = async function (_data) {\n                  try {\n                    const {\n                      type,\n                      status: status2,\n                      data: data2\n                    } = handle_message(_data, last_status[fn_index]);\n                    if (type == \"heartbeat\") {\n                      return;\n                    }\n                    if (type === \"update\" && status2 && !complete) {\n                      fire_event({\n                        type: \"status\",\n                        endpoint: _endpoint,\n                        fn_index,\n                        time: /* @__PURE__ */new Date(),\n                        ...status2\n                      });\n                    } else if (type === \"complete\") {\n                      complete = status2;\n                    } else if (type == \"unexpected_error\") {\n                      console.error(\"Unexpected error\", status2 == null ? void 0 : status2.message);\n                      fire_event({\n                        type: \"status\",\n                        stage: \"error\",\n                        message: (status2 == null ? void 0 : status2.message) || \"An Unexpected Error Occurred!\",\n                        queue: true,\n                        endpoint: _endpoint,\n                        fn_index,\n                        time: /* @__PURE__ */new Date()\n                      });\n                    } else if (type === \"log\") {\n                      fire_event({\n                        type: \"log\",\n                        log: data2.log,\n                        level: data2.level,\n                        endpoint: _endpoint,\n                        fn_index\n                      });\n                      return;\n                    } else if (type === \"generating\") {\n                      fire_event({\n                        type: \"status\",\n                        time: /* @__PURE__ */new Date(),\n                        ...status2,\n                        stage: status2 == null ? void 0 : status2.stage,\n                        queue: true,\n                        endpoint: _endpoint,\n                        fn_index\n                      });\n                    }\n                    if (data2) {\n                      fire_event({\n                        type: \"data\",\n                        time: /* @__PURE__ */new Date(),\n                        data: transform_files ? transform_output(data2.data, api_info, config.root, config.root_url) : data2.data,\n                        endpoint: _endpoint,\n                        fn_index\n                      });\n                      if (complete) {\n                        fire_event({\n                          type: \"status\",\n                          time: /* @__PURE__ */new Date(),\n                          ...complete,\n                          stage: status2 == null ? void 0 : status2.stage,\n                          queue: true,\n                          endpoint: _endpoint,\n                          fn_index\n                        });\n                      }\n                    }\n                    if ((status2 == null ? void 0 : status2.stage) === \"complete\" || (status2 == null ? void 0 : status2.stage) === \"error\") {\n                      if (event_callbacks[event_id]) {\n                        delete event_callbacks[event_id];\n                      }\n                    }\n                  } catch (e) {\n                    console.error(\"Unexpected client exception\", e);\n                    fire_event({\n                      type: \"status\",\n                      stage: \"error\",\n                      message: \"An Unexpected Error Occurred!\",\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index,\n                      time: /* @__PURE__ */new Date()\n                    });\n                    close_stream();\n                  }\n                };\n                if (event_id in pending_stream_messages) {\n                  pending_stream_messages[event_id].forEach(msg => callback(msg));\n                  delete pending_stream_messages[event_id];\n                }\n                event_callbacks[event_id] = callback;\n                unclosed_events.add(event_id);\n                if (!stream_open) {\n                  open_stream();\n                }\n              }\n            });\n          }\n        });\n        function fire_event(event) {\n          const narrowed_listener_map = listener_map;\n          const listeners = narrowed_listener_map[event.type] || [];\n          listeners == null ? void 0 : listeners.forEach(l => l(event));\n        }\n        function on(eventType, listener) {\n          const narrowed_listener_map = listener_map;\n          const listeners = narrowed_listener_map[eventType] || [];\n          narrowed_listener_map[eventType] = listeners;\n          listeners == null ? void 0 : listeners.push(listener);\n          return {\n            on,\n            off,\n            cancel,\n            destroy\n          };\n        }\n        function off(eventType, listener) {\n          const narrowed_listener_map = listener_map;\n          let listeners = narrowed_listener_map[eventType] || [];\n          listeners = listeners == null ? void 0 : listeners.filter(l => l !== listener);\n          narrowed_listener_map[eventType] = listeners;\n          return {\n            on,\n            off,\n            cancel,\n            destroy\n          };\n        }\n        async function cancel() {\n          const _status = {\n            stage: \"complete\",\n            queue: false,\n            time: /* @__PURE__ */new Date()\n          };\n          complete = _status;\n          fire_event({\n            ..._status,\n            type: \"status\",\n            endpoint: _endpoint,\n            fn_index\n          });\n          let cancel_request = {};\n          if (protocol === \"ws\") {\n            if (websocket && websocket.readyState === 0) {\n              websocket.addEventListener(\"open\", () => {\n                websocket.close();\n              });\n            } else {\n              websocket.close();\n            }\n            cancel_request = {\n              fn_index,\n              session_hash\n            };\n          } else {\n            eventSource.close();\n            cancel_request = {\n              event_id\n            };\n          }\n          try {\n            await fetch_implementation(`${config.root}/reset`, {\n              headers: {\n                \"Content-Type\": \"application/json\"\n              },\n              method: \"POST\",\n              body: JSON.stringify(cancel_request)\n            });\n          } catch (e) {\n            console.warn(\"The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable.\");\n          }\n        }\n        function destroy() {\n          for (const event_type in listener_map) {\n            listener_map[event_type].forEach(fn2 => {\n              off(event_type, fn2);\n            });\n          }\n        }\n        return {\n          on,\n          off,\n          cancel,\n          destroy\n        };\n      }\n      function open_stream() {\n        stream_open = true;\n        let params = new URLSearchParams({\n          session_hash\n        }).toString();\n        let url = new URL(`${config.root}/queue/data?${params}`);\n        event_stream = EventSource_factory(url);\n        event_stream.onmessage = async function (event) {\n          let _data = JSON.parse(event.data);\n          const event_id = _data.event_id;\n          if (!event_id) {\n            await Promise.all(Object.keys(event_callbacks).map(event_id2 => event_callbacks[event_id2](_data)));\n          } else if (event_callbacks[event_id]) {\n            if (_data.msg === \"process_completed\") {\n              unclosed_events.delete(event_id);\n              if (unclosed_events.size === 0) {\n                close_stream();\n              }\n            }\n            let fn2 = event_callbacks[event_id];\n            window.setTimeout(fn2, 0, _data);\n          } else {\n            if (!pending_stream_messages[event_id]) {\n              pending_stream_messages[event_id] = [];\n            }\n            pending_stream_messages[event_id].push(_data);\n          }\n        };\n        event_stream.onerror = async function (event) {\n          await Promise.all(Object.keys(event_callbacks).map(event_id => event_callbacks[event_id]({\n            msg: \"unexpected_error\",\n            message: BROKEN_CONNECTION_MSG\n          })));\n          close_stream();\n        };\n      }\n      function close_stream() {\n        stream_open = false;\n        event_stream == null ? void 0 : event_stream.close();\n      }\n      async function component_server(component_id, fn_name, data) {\n        var _a;\n        const headers = {\n          \"Content-Type\": \"application/json\"\n        };\n        if (hf_token) {\n          headers.Authorization = `Bearer ${hf_token}`;\n        }\n        let root_url;\n        let component = config.components.find(comp => comp.id === component_id);\n        if ((_a = component == null ? void 0 : component.props) == null ? void 0 : _a.root_url) {\n          root_url = component.props.root_url;\n        } else {\n          root_url = config.root;\n        }\n        const response = await fetch_implementation(`${root_url}/component_server/`, {\n          method: \"POST\",\n          body: JSON.stringify({\n            data,\n            component_id,\n            fn_name,\n            session_hash\n          }),\n          headers\n        });\n        if (!response.ok) {\n          throw new Error(\"Could not connect to component server: \" + response.statusText);\n        }\n        const output = await response.json();\n        return output;\n      }\n      async function view_api(config2) {\n        if (api) return api;\n        const headers = {\n          \"Content-Type\": \"application/json\"\n        };\n        if (hf_token) {\n          headers.Authorization = `Bearer ${hf_token}`;\n        }\n        let response;\n        if (semiver(config2.version || \"2.0.0\", \"3.30\") < 0) {\n          response = await fetch_implementation(\"https://gradio-space-api-fetcher-v2.hf.space/api\", {\n            method: \"POST\",\n            body: JSON.stringify({\n              serialize: false,\n              config: JSON.stringify(config2)\n            }),\n            headers\n          });\n        } else {\n          response = await fetch_implementation(`${config2.root}/info`, {\n            headers\n          });\n        }\n        if (!response.ok) {\n          throw new Error(BROKEN_CONNECTION_MSG);\n        }\n        let api_info = await response.json();\n        if (\"api\" in api_info) {\n          api_info = api_info.api;\n        }\n        if (api_info.named_endpoints[\"/predict\"] && !api_info.unnamed_endpoints[\"0\"]) {\n          api_info.unnamed_endpoints[0] = api_info.named_endpoints[\"/predict\"];\n        }\n        const x = transform_api_info(api_info, config2, api_map);\n        return x;\n      }\n    });\n  }\n  async function handle_blob2(endpoint, data, api_info, token) {\n    const blob_refs = await walk_and_store_blobs(data, void 0, [], true, api_info);\n    return Promise.all(blob_refs.map(async ({\n      path,\n      blob,\n      type\n    }) => {\n      if (blob) {\n        const file_url = (await upload_files2(endpoint, [blob], token)).files[0];\n        return {\n          path,\n          file_url,\n          type,\n          name: blob == null ? void 0 : blob.name\n        };\n      }\n      return {\n        path,\n        type\n      };\n    })).then(r => {\n      r.forEach(({\n        path,\n        file_url,\n        type,\n        name\n      }) => {\n        if (type === \"Gallery\") {\n          update_object(data, file_url, path);\n        } else if (file_url) {\n          const file = new FileData({\n            path: file_url,\n            orig_name: name\n          });\n          update_object(data, file, path);\n        }\n      });\n      return data;\n    });\n  }\n}\nconst {\n  post_data,\n  upload_files,\n  client,\n  handle_blob\n} = api_factory(fetch, (...args) => new EventSource(...args));\nfunction transform_output(data, api_info, root_url, remote_url) {\n  return data.map((d, i) => {\n    var _a, _b, _c, _d;\n    if (((_b = (_a = api_info == null ? void 0 : api_info.returns) == null ? void 0 : _a[i]) == null ? void 0 : _b.component) === \"File\") {\n      return normalise_file(d, root_url, remote_url);\n    } else if (((_d = (_c = api_info == null ? void 0 : api_info.returns) == null ? void 0 : _c[i]) == null ? void 0 : _d.component) === \"Gallery\") {\n      return d.map(img => {\n        return Array.isArray(img) ? [normalise_file(img[0], root_url, remote_url), img[1]] : [normalise_file(img, root_url, remote_url), null];\n      });\n    } else if (typeof d === \"object\" && d.path) {\n      return normalise_file(d, root_url, remote_url);\n    }\n    return d;\n  });\n}\nfunction get_type(type, component, serializer, signature_type) {\n  switch (type.type) {\n    case \"string\":\n      return \"string\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"number\":\n      return \"number\";\n  }\n  if (serializer === \"JSONSerializable\" || serializer === \"StringSerializable\") {\n    return \"any\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"string[]\";\n  } else if (component === \"Image\") {\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : \"string\";\n  } else if (serializer === \"FileSerializable\") {\n    if ((type == null ? void 0 : type.type) === \"array\") {\n      return signature_type === \"parameter\" ? \"(Blob | File | Buffer)[]\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]`;\n    }\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}`;\n  } else if (serializer === \"GallerySerializable\") {\n    return signature_type === \"parameter\" ? \"[(Blob | File | Buffer), (string | null)][]\" : `[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]`;\n  }\n}\nfunction get_description(type, serializer) {\n  if (serializer === \"GallerySerializable\") {\n    return \"array of [file, label] tuples\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"array of strings\";\n  } else if (serializer === \"FileSerializable\") {\n    return \"array of files or single file\";\n  }\n  return type.description;\n}\nfunction transform_api_info(api_info, config, api_map) {\n  const new_data = {\n    named_endpoints: {},\n    unnamed_endpoints: {}\n  };\n  for (const key in api_info) {\n    const cat = api_info[key];\n    for (const endpoint in cat) {\n      const dep_index = config.dependencies[endpoint] ? endpoint : api_map[endpoint.replace(\"/\", \"\")];\n      const info = cat[endpoint];\n      new_data[key][endpoint] = {};\n      new_data[key][endpoint].parameters = {};\n      new_data[key][endpoint].returns = {};\n      new_data[key][endpoint].type = config.dependencies[dep_index].types;\n      new_data[key][endpoint].parameters = info.parameters.map(({\n        label,\n        component,\n        type,\n        serializer\n      }) => ({\n        label,\n        component,\n        type: get_type(type, component, serializer, \"parameter\"),\n        description: get_description(type, serializer)\n      }));\n      new_data[key][endpoint].returns = info.returns.map(({\n        label,\n        component,\n        type,\n        serializer\n      }) => ({\n        label,\n        component,\n        type: get_type(type, component, serializer, \"return\"),\n        description: get_description(type, serializer)\n      }));\n    }\n  }\n  return new_data;\n}\nasync function get_jwt(space, token) {\n  try {\n    const r = await fetch(`https://huggingface.co/api/spaces/${space}/jwt`, {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n    const jwt = (await r.json()).token;\n    return jwt || false;\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\nfunction update_object(object, newValue, stack) {\n  while (stack.length > 1) {\n    object = object[stack.shift()];\n  }\n  object[stack.shift()] = newValue;\n}\nasync function walk_and_store_blobs(param, type = void 0, path = [], root = false, api_info = void 0) {\n  if (Array.isArray(param)) {\n    let blob_refs = [];\n    await Promise.all(param.map(async (v, i) => {\n      var _a;\n      let new_path = path.slice();\n      new_path.push(i);\n      const array_refs = await walk_and_store_blobs(param[i], root ? ((_a = api_info == null ? void 0 : api_info.parameters[i]) == null ? void 0 : _a.component) || void 0 : type, new_path, false, api_info);\n      blob_refs = blob_refs.concat(array_refs);\n    }));\n    return blob_refs;\n  } else if (globalThis.Buffer && param instanceof globalThis.Buffer) {\n    const is_image = type === \"Image\";\n    return [{\n      path,\n      blob: is_image ? false : new NodeBlob([param]),\n      type\n    }];\n  } else if (typeof param === \"object\") {\n    let blob_refs = [];\n    for (let key in param) {\n      if (param.hasOwnProperty(key)) {\n        let new_path = path.slice();\n        new_path.push(key);\n        blob_refs = blob_refs.concat(await walk_and_store_blobs(param[key], void 0, new_path, false, api_info));\n      }\n    }\n    return blob_refs;\n  }\n  return [];\n}\nfunction skip_queue(id, config) {\n  var _a, _b, _c, _d;\n  return !(((_b = (_a = config == null ? void 0 : config.dependencies) == null ? void 0 : _a[id]) == null ? void 0 : _b.queue) === null ? config.enable_queue : (_d = (_c = config == null ? void 0 : config.dependencies) == null ? void 0 : _c[id]) == null ? void 0 : _d.queue) || false;\n}\nasync function resolve_config(fetch_implementation, endpoint, token) {\n  const headers = {};\n  if (token) {\n    headers.Authorization = `Bearer ${token}`;\n  }\n  if (typeof window !== \"undefined\" && window.gradio_config && location.origin !== \"http://localhost:9876\" && !window.gradio_config.dev_mode) {\n    const path = window.gradio_config.root;\n    const config = window.gradio_config;\n    config.root = resolve_root(endpoint, config.root, false);\n    return {\n      ...config,\n      path\n    };\n  } else if (endpoint) {\n    let response = await fetch_implementation(`${endpoint}/config`, {\n      headers\n    });\n    if (response.status === 200) {\n      const config = await response.json();\n      config.path = config.path ?? \"\";\n      config.root = endpoint;\n      return config;\n    }\n    throw new Error(\"Could not get config.\");\n  }\n  throw new Error(\"No config or app endpoint found\");\n}\nasync function check_space_status(id, type, status_callback) {\n  let endpoint = type === \"subdomain\" ? `https://huggingface.co/api/spaces/by-subdomain/${id}` : `https://huggingface.co/api/spaces/${id}`;\n  let response;\n  let _status;\n  try {\n    response = await fetch(endpoint);\n    _status = response.status;\n    if (_status !== 200) {\n      throw new Error();\n    }\n    response = await response.json();\n  } catch (e) {\n    status_callback({\n      status: \"error\",\n      load_status: \"error\",\n      message: \"Could not get space status\",\n      detail: \"NOT_FOUND\"\n    });\n    return;\n  }\n  if (!response || _status !== 200) return;\n  const {\n    runtime: {\n      stage\n    },\n    id: space_name\n  } = response;\n  switch (stage) {\n    case \"STOPPED\":\n    case \"SLEEPING\":\n      status_callback({\n        status: \"sleeping\",\n        load_status: \"pending\",\n        message: \"Space is asleep. Waking it up...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"PAUSED\":\n      status_callback({\n        status: \"paused\",\n        load_status: \"error\",\n        message: \"This space has been paused by the author. If you would like to try this demo, consider duplicating the space.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n    case \"RUNNING\":\n    case \"RUNNING_BUILDING\":\n      status_callback({\n        status: \"running\",\n        load_status: \"complete\",\n        message: \"\",\n        detail: stage\n      });\n      break;\n    case \"BUILDING\":\n      status_callback({\n        status: \"building\",\n        load_status: \"pending\",\n        message: \"Space is building...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    default:\n      status_callback({\n        status: \"space_error\",\n        load_status: \"error\",\n        message: \"This space is experiencing an issue.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n  }\n}\nfunction handle_message(data, last_status) {\n  const queue = true;\n  switch (data.msg) {\n    case \"send_data\":\n      return {\n        type: \"data\"\n      };\n    case \"send_hash\":\n      return {\n        type: \"hash\"\n      };\n    case \"queue_full\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          message: QUEUE_FULL_MSG,\n          stage: \"error\",\n          code: data.code,\n          success: data.success\n        }\n      };\n    case \"heartbeat\":\n      return {\n        type: \"heartbeat\"\n      };\n    case \"unexpected_error\":\n      return {\n        type: \"unexpected_error\",\n        status: {\n          queue,\n          message: data.message,\n          stage: \"error\",\n          success: false\n        }\n      };\n    case \"estimation\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: last_status || \"pending\",\n          code: data.code,\n          size: data.queue_size,\n          position: data.rank,\n          eta: data.rank_eta,\n          success: data.success\n        }\n      };\n    case \"progress\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          progress_data: data.progress_data,\n          success: data.success\n        }\n      };\n    case \"log\":\n      return {\n        type: \"log\",\n        data\n      };\n    case \"process_generating\":\n      return {\n        type: \"generating\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : null,\n          stage: data.success ? \"generating\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          eta: data.average_duration\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_completed\":\n      if (\"error\" in data.output) {\n        return {\n          type: \"update\",\n          status: {\n            queue,\n            message: data.output.error,\n            stage: \"error\",\n            code: data.code,\n            success: data.success\n          }\n        };\n      }\n      return {\n        type: \"complete\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : void 0,\n          stage: data.success ? \"complete\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_starts\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          size: data.rank,\n          position: 0,\n          success: data.success,\n          eta: data.eta\n        }\n      };\n  }\n  return {\n    type: \"none\",\n    status: {\n      stage: \"error\",\n      queue\n    }\n  };\n}\nexport { FileData, api_factory, client, duplicate, get_fetchable_url_or_file, normalise_file, post_data, prepare_files, upload, upload_files };","map":{"version":3,"names":["fn","Intl","Collator","numeric","compare","semiver","a","b","bool","split","slice","join","test","resolve_root","base_url","root_path","prioritize_base","startsWith","determine_protocol","endpoint","protocol","host","URL","endsWith","ws_protocol","http_protocol","RE_SPACE_NAME","RE_SPACE_DOMAIN","process_endpoint","app_reference","token","headers","Authorization","_app_reference","trim","res","fetch","status","Error","_host","json","space_id","e","message","replace","map_names_to_ids","fns","apis","forEach","api_name","i","RE_DISABLED_DISCUSSION","discussions_enabled","r","method","error","get","get_space_hardware","hardware","set_space_hardware","new_hardware","body","JSON","stringify","set_space_timeout","timeout","seconds","hardware_types","normalise_file","file","server_url","proxy_url","Array","isArray","normalized_file","x","push","is_stream","FileData","url","path","get_fetchable_url_or_file","is_url","str","upload","file_data","root","upload_id","upload_fn","upload_files","files","map","file_data2","blob","Promise","all","then","response","f","prepare_files","name","orig_name","size","mime_type","type","constructor","alt_text","QUEUE_FULL_MSG","BROKEN_CONNECTION_MSG","NodeBlob","duplicate","options","hf_token","private","_private","includes","v","user","space_name","repository","client","duplicated_space","original_hardware","requested_hardware","api_factory","fetch_implementation","EventSource_factory","post_data","post_data2","upload_files2","client2","handle_blob","handle_blob2","output","chunkSize","uploadResponses","length","chunk","formData","FormData","append","upload_url","normalise_files","status_callback","return_obj","predict","submit","view_api","component_server","transform_files","window","global","Websocket","ws","Blob","WebSocket","session_hash","Math","random","toString","substring","last_status","stream_open","pending_stream_messages","event_stream","event_callbacks","unclosed_events","Set","config","api_map","jwt","get_jwt","config_success","_config","dependencies","auth_required","api","console","handle_space_sucess","resolve_config","load_status","detail","check_space_status","data","event_data","data_returned","status_complete","dependency","trimmed_endpoint","types","continuous","res2","rej","app","result","on","d","destroy","stage","trigger_id","fn_index","api_info","unnamed_endpoints","named_endpoints","websocket","eventSource","_endpoint","payload","event_id","complete","listener_map","url_params","URLSearchParams","location","search","_payload","skip_queue","fire_event","queue","time","Date","status_code","data2","transform_output","root_url","eta","average_duration","catch","searchParams","set","onclose","evt","wasClean","broken","onmessage","event","_data","parse","handle_message","close","send","log","level","version","addEventListener","hash","params","_","status2","callback","close_stream","msg","add","open_stream","narrowed_listener_map","listeners","l","eventType","listener","off","cancel","filter","_status","cancel_request","readyState","warn","event_type","fn2","Object","keys","event_id2","delete","setTimeout","onerror","component_id","fn_name","_a","component","components","find","comp","id","props","ok","statusText","config2","serialize","transform_api_info","blob_refs","walk_and_store_blobs","file_url","update_object","args","EventSource","remote_url","_b","_c","_d","returns","img","get_type","serializer","signature_type","get_description","description","new_data","key","cat","dep_index","info","parameters","label","space","object","newValue","stack","shift","param","new_path","array_refs","concat","globalThis","Buffer","is_image","hasOwnProperty","enable_queue","gradio_config","origin","dev_mode","runtime","code","success","queue_size","position","rank","rank_eta","progress_data"],"sources":["C:/Users/juju7/starry-eyed/node_modules/@gradio/client/dist/index.js"],"sourcesContent":["var fn = new Intl.Collator(0, { numeric: 1 }).compare;\r\nfunction semiver(a, b, bool) {\r\n  a = a.split(\".\");\r\n  b = b.split(\".\");\r\n  return fn(a[0], b[0]) || fn(a[1], b[1]) || (b[2] = b.slice(2).join(\".\"), bool = /[.-]/.test(a[2] = a.slice(2).join(\".\")), bool == /[.-]/.test(b[2]) ? fn(a[2], b[2]) : bool ? -1 : 1);\r\n}\r\nfunction resolve_root(base_url, root_path, prioritize_base) {\r\n  if (root_path.startsWith(\"http://\") || root_path.startsWith(\"https://\")) {\r\n    return prioritize_base ? base_url : root_path;\r\n  }\r\n  return base_url + root_path;\r\n}\r\nfunction determine_protocol(endpoint) {\r\n  if (endpoint.startsWith(\"http\")) {\r\n    const { protocol, host } = new URL(endpoint);\r\n    if (host.endsWith(\"hf.space\")) {\r\n      return {\r\n        ws_protocol: \"wss\",\r\n        host,\r\n        http_protocol: protocol\r\n      };\r\n    }\r\n    return {\r\n      ws_protocol: protocol === \"https:\" ? \"wss\" : \"ws\",\r\n      http_protocol: protocol,\r\n      host\r\n    };\r\n  } else if (endpoint.startsWith(\"file:\")) {\r\n    return {\r\n      ws_protocol: \"ws\",\r\n      http_protocol: \"http:\",\r\n      host: \"lite.local\"\r\n      // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.\r\n    };\r\n  }\r\n  return {\r\n    ws_protocol: \"wss\",\r\n    http_protocol: \"https:\",\r\n    host: endpoint\r\n  };\r\n}\r\nconst RE_SPACE_NAME = /^[^\\/]*\\/[^\\/]*$/;\r\nconst RE_SPACE_DOMAIN = /.*hf\\.space\\/{0,1}$/;\r\nasync function process_endpoint(app_reference, token) {\r\n  const headers = {};\r\n  if (token) {\r\n    headers.Authorization = `Bearer ${token}`;\r\n  }\r\n  const _app_reference = app_reference.trim();\r\n  if (RE_SPACE_NAME.test(_app_reference)) {\r\n    try {\r\n      const res = await fetch(\r\n        `https://huggingface.co/api/spaces/${_app_reference}/host`,\r\n        { headers }\r\n      );\r\n      if (res.status !== 200)\r\n        throw new Error(\"Space metadata could not be loaded.\");\r\n      const _host = (await res.json()).host;\r\n      return {\r\n        space_id: app_reference,\r\n        ...determine_protocol(_host)\r\n      };\r\n    } catch (e) {\r\n      throw new Error(\"Space metadata could not be loaded.\" + e.message);\r\n    }\r\n  }\r\n  if (RE_SPACE_DOMAIN.test(_app_reference)) {\r\n    const { ws_protocol, http_protocol, host } = determine_protocol(_app_reference);\r\n    return {\r\n      space_id: host.replace(\".hf.space\", \"\"),\r\n      ws_protocol,\r\n      http_protocol,\r\n      host\r\n    };\r\n  }\r\n  return {\r\n    space_id: false,\r\n    ...determine_protocol(_app_reference)\r\n  };\r\n}\r\nfunction map_names_to_ids(fns) {\r\n  let apis = {};\r\n  fns.forEach(({ api_name }, i) => {\r\n    if (api_name)\r\n      apis[api_name] = i;\r\n  });\r\n  return apis;\r\n}\r\nconst RE_DISABLED_DISCUSSION = /^(?=[^]*\\b[dD]iscussions{0,1}\\b)(?=[^]*\\b[dD]isabled\\b)[^]*$/;\r\nasync function discussions_enabled(space_id) {\r\n  try {\r\n    const r = await fetch(\r\n      `https://huggingface.co/api/spaces/${space_id}/discussions`,\r\n      {\r\n        method: \"HEAD\"\r\n      }\r\n    );\r\n    const error = r.headers.get(\"x-error-message\");\r\n    if (error && RE_DISABLED_DISCUSSION.test(error))\r\n      return false;\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\nasync function get_space_hardware(space_id, token) {\r\n  const headers = {};\r\n  if (token) {\r\n    headers.Authorization = `Bearer ${token}`;\r\n  }\r\n  try {\r\n    const res = await fetch(\r\n      `https://huggingface.co/api/spaces/${space_id}/runtime`,\r\n      { headers }\r\n    );\r\n    if (res.status !== 200)\r\n      throw new Error(\"Space hardware could not be obtained.\");\r\n    const { hardware } = await res.json();\r\n    return hardware;\r\n  } catch (e) {\r\n    throw new Error(e.message);\r\n  }\r\n}\r\nasync function set_space_hardware(space_id, new_hardware, token) {\r\n  const headers = {};\r\n  if (token) {\r\n    headers.Authorization = `Bearer ${token}`;\r\n  }\r\n  try {\r\n    const res = await fetch(\r\n      `https://huggingface.co/api/spaces/${space_id}/hardware`,\r\n      { headers, body: JSON.stringify(new_hardware) }\r\n    );\r\n    if (res.status !== 200)\r\n      throw new Error(\r\n        \"Space hardware could not be set. Please ensure the space hardware provided is valid and that a Hugging Face token is passed in.\"\r\n      );\r\n    const { hardware } = await res.json();\r\n    return hardware;\r\n  } catch (e) {\r\n    throw new Error(e.message);\r\n  }\r\n}\r\nasync function set_space_timeout(space_id, timeout, token) {\r\n  const headers = {};\r\n  if (token) {\r\n    headers.Authorization = `Bearer ${token}`;\r\n  }\r\n  try {\r\n    const res = await fetch(\r\n      `https://huggingface.co/api/spaces/${space_id}/hardware`,\r\n      { headers, body: JSON.stringify({ seconds: timeout }) }\r\n    );\r\n    if (res.status !== 200)\r\n      throw new Error(\r\n        \"Space hardware could not be set. Please ensure the space hardware provided is valid and that a Hugging Face token is passed in.\"\r\n      );\r\n    const { hardware } = await res.json();\r\n    return hardware;\r\n  } catch (e) {\r\n    throw new Error(e.message);\r\n  }\r\n}\r\nconst hardware_types = [\r\n  \"cpu-basic\",\r\n  \"cpu-upgrade\",\r\n  \"t4-small\",\r\n  \"t4-medium\",\r\n  \"a10g-small\",\r\n  \"a10g-large\",\r\n  \"a100-large\"\r\n];\r\nfunction normalise_file(file, server_url, proxy_url) {\r\n  if (file == null) {\r\n    return null;\r\n  }\r\n  if (Array.isArray(file)) {\r\n    const normalized_file = [];\r\n    for (const x of file) {\r\n      if (x == null) {\r\n        normalized_file.push(null);\r\n      } else {\r\n        normalized_file.push(normalise_file(x, server_url, proxy_url));\r\n      }\r\n    }\r\n    return normalized_file;\r\n  }\r\n  if (file.is_stream) {\r\n    if (proxy_url == null) {\r\n      return new FileData({\r\n        ...file,\r\n        url: server_url + \"/stream/\" + file.path\r\n      });\r\n    }\r\n    return new FileData({\r\n      ...file,\r\n      url: \"/proxy=\" + proxy_url + \"stream/\" + file.path\r\n    });\r\n  }\r\n  return new FileData({\r\n    ...file,\r\n    url: get_fetchable_url_or_file(file.path, server_url, proxy_url)\r\n  });\r\n}\r\nfunction is_url(str) {\r\n  try {\r\n    const url = new URL(str);\r\n    return url.protocol === \"http:\" || url.protocol === \"https:\";\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\nfunction get_fetchable_url_or_file(path, server_url, proxy_url) {\r\n  if (path == null) {\r\n    return proxy_url ? `/proxy=${proxy_url}file=` : `${server_url}/file=`;\r\n  }\r\n  if (is_url(path)) {\r\n    return path;\r\n  }\r\n  return proxy_url ? `/proxy=${proxy_url}file=${path}` : `${server_url}/file=${path}`;\r\n}\r\nasync function upload(file_data, root, upload_id, upload_fn = upload_files) {\r\n  let files = (Array.isArray(file_data) ? file_data : [file_data]).map(\r\n    (file_data2) => file_data2.blob\r\n  );\r\n  return await Promise.all(\r\n    await upload_fn(root, files, void 0, upload_id).then(\r\n      async (response) => {\r\n        if (response.error) {\r\n          throw new Error(response.error);\r\n        } else {\r\n          if (response.files) {\r\n            return response.files.map((f, i) => {\r\n              const file = new FileData({ ...file_data[i], path: f });\r\n              return normalise_file(file, root, null);\r\n            });\r\n          }\r\n          return [];\r\n        }\r\n      }\r\n    )\r\n  );\r\n}\r\nasync function prepare_files(files, is_stream) {\r\n  return files.map(\r\n    (f, i) => new FileData({\r\n      path: f.name,\r\n      orig_name: f.name,\r\n      blob: f,\r\n      size: f.size,\r\n      mime_type: f.type,\r\n      is_stream\r\n    })\r\n  );\r\n}\r\nclass FileData {\r\n  constructor({\r\n    path,\r\n    url,\r\n    orig_name,\r\n    size,\r\n    blob,\r\n    is_stream,\r\n    mime_type,\r\n    alt_text\r\n  }) {\r\n    this.path = path;\r\n    this.url = url;\r\n    this.orig_name = orig_name;\r\n    this.size = size;\r\n    this.blob = url ? void 0 : blob;\r\n    this.is_stream = is_stream;\r\n    this.mime_type = mime_type;\r\n    this.alt_text = alt_text;\r\n  }\r\n}\r\nconst QUEUE_FULL_MSG = \"This application is too busy. Keep trying!\";\r\nconst BROKEN_CONNECTION_MSG = \"Connection errored out.\";\r\nlet NodeBlob;\r\nasync function duplicate(app_reference, options) {\r\n  const { hf_token, private: _private, hardware, timeout } = options;\r\n  if (hardware && !hardware_types.includes(hardware)) {\r\n    throw new Error(\r\n      `Invalid hardware type provided. Valid types are: ${hardware_types.map((v) => `\"${v}\"`).join(\",\")}.`\r\n    );\r\n  }\r\n  const headers = {\r\n    Authorization: `Bearer ${hf_token}`\r\n  };\r\n  const user = (await (await fetch(`https://huggingface.co/api/whoami-v2`, {\r\n    headers\r\n  })).json()).name;\r\n  const space_name = app_reference.split(\"/\")[1];\r\n  const body = {\r\n    repository: `${user}/${space_name}`\r\n  };\r\n  if (_private) {\r\n    body.private = true;\r\n  }\r\n  try {\r\n    const response = await fetch(\r\n      `https://huggingface.co/api/spaces/${app_reference}/duplicate`,\r\n      {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\", ...headers },\r\n        body: JSON.stringify(body)\r\n      }\r\n    );\r\n    if (response.status === 409) {\r\n      return client(`${user}/${space_name}`, options);\r\n    }\r\n    const duplicated_space = await response.json();\r\n    let original_hardware;\r\n    if (!hardware) {\r\n      original_hardware = await get_space_hardware(app_reference, hf_token);\r\n    }\r\n    const requested_hardware = hardware || original_hardware || \"cpu-basic\";\r\n    await set_space_hardware(\r\n      `${user}/${space_name}`,\r\n      requested_hardware,\r\n      hf_token\r\n    );\r\n    await set_space_timeout(`${user}/${space_name}`, timeout || 300, hf_token);\r\n    return client(duplicated_space.url, options);\r\n  } catch (e) {\r\n    throw new Error(e);\r\n  }\r\n}\r\nfunction api_factory(fetch_implementation, EventSource_factory) {\r\n  return { post_data: post_data2, upload_files: upload_files2, client: client2, handle_blob: handle_blob2 };\r\n  async function post_data2(url, body, token) {\r\n    const headers = { \"Content-Type\": \"application/json\" };\r\n    if (token) {\r\n      headers.Authorization = `Bearer ${token}`;\r\n    }\r\n    try {\r\n      var response = await fetch_implementation(url, {\r\n        method: \"POST\",\r\n        body: JSON.stringify(body),\r\n        headers\r\n      });\r\n    } catch (e) {\r\n      return [{ error: BROKEN_CONNECTION_MSG }, 500];\r\n    }\r\n    let output;\r\n    let status;\r\n    try {\r\n      output = await response.json();\r\n      status = response.status;\r\n    } catch (e) {\r\n      output = { error: `Could not parse server response: ${e}` };\r\n      status = 500;\r\n    }\r\n    return [output, status];\r\n  }\r\n  async function upload_files2(root, files, token, upload_id) {\r\n    const headers = {};\r\n    if (token) {\r\n      headers.Authorization = `Bearer ${token}`;\r\n    }\r\n    const chunkSize = 1e3;\r\n    const uploadResponses = [];\r\n    for (let i = 0; i < files.length; i += chunkSize) {\r\n      const chunk = files.slice(i, i + chunkSize);\r\n      const formData = new FormData();\r\n      chunk.forEach((file) => {\r\n        formData.append(\"files\", file);\r\n      });\r\n      try {\r\n        const upload_url = upload_id ? `${root}/upload?upload_id=${upload_id}` : `${root}/upload`;\r\n        var response = await fetch_implementation(upload_url, {\r\n          method: \"POST\",\r\n          body: formData,\r\n          headers\r\n        });\r\n      } catch (e) {\r\n        return { error: BROKEN_CONNECTION_MSG };\r\n      }\r\n      const output = await response.json();\r\n      uploadResponses.push(...output);\r\n    }\r\n    return { files: uploadResponses };\r\n  }\r\n  async function client2(app_reference, options = { normalise_files: true }) {\r\n    return new Promise(async (res) => {\r\n      const { status_callback, hf_token, normalise_files } = options;\r\n      const return_obj = {\r\n        predict,\r\n        submit,\r\n        view_api,\r\n        component_server\r\n      };\r\n      const transform_files = normalise_files ?? true;\r\n      if ((typeof window === \"undefined\" || !(\"WebSocket\" in window)) && !global.Websocket) {\r\n        const ws = await import(\"./wrapper-6f348d45.js\");\r\n        NodeBlob = (await import(\"node:buffer\")).Blob;\r\n        global.WebSocket = ws.WebSocket;\r\n      }\r\n      const { ws_protocol, http_protocol, host, space_id } = await process_endpoint(app_reference, hf_token);\r\n      const session_hash = Math.random().toString(36).substring(2);\r\n      const last_status = {};\r\n      let stream_open = false;\r\n      let pending_stream_messages = {};\r\n      let event_stream = null;\r\n      const event_callbacks = {};\r\n      const unclosed_events = /* @__PURE__ */ new Set();\r\n      let config;\r\n      let api_map = {};\r\n      let jwt = false;\r\n      if (hf_token && space_id) {\r\n        jwt = await get_jwt(space_id, hf_token);\r\n      }\r\n      async function config_success(_config) {\r\n        config = _config;\r\n        api_map = map_names_to_ids((_config == null ? void 0 : _config.dependencies) || []);\r\n        if (config.auth_required) {\r\n          return {\r\n            config,\r\n            ...return_obj\r\n          };\r\n        }\r\n        try {\r\n          api = await view_api(config);\r\n        } catch (e) {\r\n          console.error(`Could not get api details: ${e.message}`);\r\n        }\r\n        return {\r\n          config,\r\n          ...return_obj\r\n        };\r\n      }\r\n      let api;\r\n      async function handle_space_sucess(status) {\r\n        if (status_callback)\r\n          status_callback(status);\r\n        if (status.status === \"running\")\r\n          try {\r\n            config = await resolve_config(\r\n              fetch_implementation,\r\n              `${http_protocol}//${host}`,\r\n              hf_token\r\n            );\r\n            const _config = await config_success(config);\r\n            res(_config);\r\n          } catch (e) {\r\n            console.error(e);\r\n            if (status_callback) {\r\n              status_callback({\r\n                status: \"error\",\r\n                message: \"Could not load this space.\",\r\n                load_status: \"error\",\r\n                detail: \"NOT_FOUND\"\r\n              });\r\n            }\r\n          }\r\n      }\r\n      try {\r\n        config = await resolve_config(\r\n          fetch_implementation,\r\n          `${http_protocol}//${host}`,\r\n          hf_token\r\n        );\r\n        const _config = await config_success(config);\r\n        res(_config);\r\n      } catch (e) {\r\n        console.error(e);\r\n        if (space_id) {\r\n          check_space_status(\r\n            space_id,\r\n            RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\",\r\n            handle_space_sucess\r\n          );\r\n        } else {\r\n          if (status_callback)\r\n            status_callback({\r\n              status: \"error\",\r\n              message: \"Could not load this space.\",\r\n              load_status: \"error\",\r\n              detail: \"NOT_FOUND\"\r\n            });\r\n        }\r\n      }\r\n      function predict(endpoint, data, event_data) {\r\n        let data_returned = false;\r\n        let status_complete = false;\r\n        let dependency;\r\n        if (typeof endpoint === \"number\") {\r\n          dependency = config.dependencies[endpoint];\r\n        } else {\r\n          const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\r\n          dependency = config.dependencies[api_map[trimmed_endpoint]];\r\n        }\r\n        if (dependency.types.continuous) {\r\n          throw new Error(\r\n            \"Cannot call predict on this function as it may run forever. Use submit instead\"\r\n          );\r\n        }\r\n        return new Promise((res2, rej) => {\r\n          const app = submit(endpoint, data, event_data);\r\n          let result;\r\n          app.on(\"data\", (d) => {\r\n            if (status_complete) {\r\n              app.destroy();\r\n              res2(d);\r\n            }\r\n            data_returned = true;\r\n            result = d;\r\n          }).on(\"status\", (status) => {\r\n            if (status.stage === \"error\")\r\n              rej(status);\r\n            if (status.stage === \"complete\") {\r\n              status_complete = true;\r\n              if (data_returned) {\r\n                app.destroy();\r\n                res2(result);\r\n              }\r\n            }\r\n          });\r\n        });\r\n      }\r\n      function submit(endpoint, data, event_data, trigger_id = null) {\r\n        let fn_index;\r\n        let api_info;\r\n        if (typeof endpoint === \"number\") {\r\n          fn_index = endpoint;\r\n          api_info = api.unnamed_endpoints[fn_index];\r\n        } else {\r\n          const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\r\n          fn_index = api_map[trimmed_endpoint];\r\n          api_info = api.named_endpoints[endpoint.trim()];\r\n        }\r\n        if (typeof fn_index !== \"number\") {\r\n          throw new Error(\r\n            \"There is no endpoint matching that name of fn_index matching that number.\"\r\n          );\r\n        }\r\n        let websocket;\r\n        let eventSource;\r\n        let protocol = config.protocol ?? \"ws\";\r\n        const _endpoint = typeof endpoint === \"number\" ? \"/predict\" : endpoint;\r\n        let payload;\r\n        let event_id = null;\r\n        let complete = false;\r\n        const listener_map = {};\r\n        let url_params = \"\";\r\n        if (typeof window !== \"undefined\") {\r\n          url_params = new URLSearchParams(window.location.search).toString();\r\n        }\r\n        handle_blob2(`${config.root}`, data, api_info, hf_token).then(\r\n          (_payload) => {\r\n            payload = {\r\n              data: _payload || [],\r\n              event_data,\r\n              fn_index,\r\n              trigger_id\r\n            };\r\n            if (skip_queue(fn_index, config)) {\r\n              fire_event({\r\n                type: \"status\",\r\n                endpoint: _endpoint,\r\n                stage: \"pending\",\r\n                queue: false,\r\n                fn_index,\r\n                time: /* @__PURE__ */ new Date()\r\n              });\r\n              post_data2(\r\n                `${config.root}/run${_endpoint.startsWith(\"/\") ? _endpoint : `/${_endpoint}`}${url_params ? \"?\" + url_params : \"\"}`,\r\n                {\r\n                  ...payload,\r\n                  session_hash\r\n                },\r\n                hf_token\r\n              ).then(([output, status_code]) => {\r\n                const data2 = transform_files ? transform_output(\r\n                  output.data,\r\n                  api_info,\r\n                  config.root,\r\n                  config.root_url\r\n                ) : output.data;\r\n                if (status_code == 200) {\r\n                  fire_event({\r\n                    type: \"data\",\r\n                    endpoint: _endpoint,\r\n                    fn_index,\r\n                    data: data2,\r\n                    time: /* @__PURE__ */ new Date()\r\n                  });\r\n                  fire_event({\r\n                    type: \"status\",\r\n                    endpoint: _endpoint,\r\n                    fn_index,\r\n                    stage: \"complete\",\r\n                    eta: output.average_duration,\r\n                    queue: false,\r\n                    time: /* @__PURE__ */ new Date()\r\n                  });\r\n                } else {\r\n                  fire_event({\r\n                    type: \"status\",\r\n                    stage: \"error\",\r\n                    endpoint: _endpoint,\r\n                    fn_index,\r\n                    message: output.error,\r\n                    queue: false,\r\n                    time: /* @__PURE__ */ new Date()\r\n                  });\r\n                }\r\n              }).catch((e) => {\r\n                fire_event({\r\n                  type: \"status\",\r\n                  stage: \"error\",\r\n                  message: e.message,\r\n                  endpoint: _endpoint,\r\n                  fn_index,\r\n                  queue: false,\r\n                  time: /* @__PURE__ */ new Date()\r\n                });\r\n              });\r\n            } else if (protocol == \"ws\") {\r\n              fire_event({\r\n                type: \"status\",\r\n                stage: \"pending\",\r\n                queue: true,\r\n                endpoint: _endpoint,\r\n                fn_index,\r\n                time: /* @__PURE__ */ new Date()\r\n              });\r\n              let url = new URL(`${ws_protocol}://${resolve_root(\r\n                host,\r\n                config.path,\r\n                true\r\n              )}\r\n\t\t\t\t\t\t\t/queue/join${url_params ? \"?\" + url_params : \"\"}`);\r\n              if (jwt) {\r\n                url.searchParams.set(\"__sign\", jwt);\r\n              }\r\n              websocket = new WebSocket(url);\r\n              websocket.onclose = (evt) => {\r\n                if (!evt.wasClean) {\r\n                  fire_event({\r\n                    type: \"status\",\r\n                    stage: \"error\",\r\n                    broken: true,\r\n                    message: BROKEN_CONNECTION_MSG,\r\n                    queue: true,\r\n                    endpoint: _endpoint,\r\n                    fn_index,\r\n                    time: /* @__PURE__ */ new Date()\r\n                  });\r\n                }\r\n              };\r\n              websocket.onmessage = function(event) {\r\n                const _data = JSON.parse(event.data);\r\n                const { type, status, data: data2 } = handle_message(\r\n                  _data,\r\n                  last_status[fn_index]\r\n                );\r\n                if (type === \"update\" && status && !complete) {\r\n                  fire_event({\r\n                    type: \"status\",\r\n                    endpoint: _endpoint,\r\n                    fn_index,\r\n                    time: /* @__PURE__ */ new Date(),\r\n                    ...status\r\n                  });\r\n                  if (status.stage === \"error\") {\r\n                    websocket.close();\r\n                  }\r\n                } else if (type === \"hash\") {\r\n                  websocket.send(JSON.stringify({ fn_index, session_hash }));\r\n                  return;\r\n                } else if (type === \"data\") {\r\n                  websocket.send(JSON.stringify({ ...payload, session_hash }));\r\n                } else if (type === \"complete\") {\r\n                  complete = status;\r\n                } else if (type === \"log\") {\r\n                  fire_event({\r\n                    type: \"log\",\r\n                    log: data2.log,\r\n                    level: data2.level,\r\n                    endpoint: _endpoint,\r\n                    fn_index\r\n                  });\r\n                } else if (type === \"generating\") {\r\n                  fire_event({\r\n                    type: \"status\",\r\n                    time: /* @__PURE__ */ new Date(),\r\n                    ...status,\r\n                    stage: status == null ? void 0 : status.stage,\r\n                    queue: true,\r\n                    endpoint: _endpoint,\r\n                    fn_index\r\n                  });\r\n                }\r\n                if (data2) {\r\n                  fire_event({\r\n                    type: \"data\",\r\n                    time: /* @__PURE__ */ new Date(),\r\n                    data: transform_files ? transform_output(\r\n                      data2.data,\r\n                      api_info,\r\n                      config.root,\r\n                      config.root_url\r\n                    ) : data2.data,\r\n                    endpoint: _endpoint,\r\n                    fn_index\r\n                  });\r\n                  if (complete) {\r\n                    fire_event({\r\n                      type: \"status\",\r\n                      time: /* @__PURE__ */ new Date(),\r\n                      ...complete,\r\n                      stage: status == null ? void 0 : status.stage,\r\n                      queue: true,\r\n                      endpoint: _endpoint,\r\n                      fn_index\r\n                    });\r\n                    websocket.close();\r\n                  }\r\n                }\r\n              };\r\n              if (semiver(config.version || \"2.0.0\", \"3.6\") < 0) {\r\n                addEventListener(\r\n                  \"open\",\r\n                  () => websocket.send(JSON.stringify({ hash: session_hash }))\r\n                );\r\n              }\r\n            } else if (protocol == \"sse\") {\r\n              fire_event({\r\n                type: \"status\",\r\n                stage: \"pending\",\r\n                queue: true,\r\n                endpoint: _endpoint,\r\n                fn_index,\r\n                time: /* @__PURE__ */ new Date()\r\n              });\r\n              var params = new URLSearchParams({\r\n                fn_index: fn_index.toString(),\r\n                session_hash\r\n              }).toString();\r\n              let url = new URL(\r\n                `${config.root}/queue/join?${url_params ? url_params + \"&\" : \"\"}${params}`\r\n              );\r\n              eventSource = EventSource_factory(url);\r\n              eventSource.onmessage = async function(event) {\r\n                const _data = JSON.parse(event.data);\r\n                const { type, status, data: data2 } = handle_message(\r\n                  _data,\r\n                  last_status[fn_index]\r\n                );\r\n                if (type === \"update\" && status && !complete) {\r\n                  fire_event({\r\n                    type: \"status\",\r\n                    endpoint: _endpoint,\r\n                    fn_index,\r\n                    time: /* @__PURE__ */ new Date(),\r\n                    ...status\r\n                  });\r\n                  if (status.stage === \"error\") {\r\n                    eventSource.close();\r\n                  }\r\n                } else if (type === \"data\") {\r\n                  event_id = _data.event_id;\r\n                  let [_, status2] = await post_data2(\r\n                    `${config.root}/queue/data`,\r\n                    {\r\n                      ...payload,\r\n                      session_hash,\r\n                      event_id\r\n                    },\r\n                    hf_token\r\n                  );\r\n                  if (status2 !== 200) {\r\n                    fire_event({\r\n                      type: \"status\",\r\n                      stage: \"error\",\r\n                      message: BROKEN_CONNECTION_MSG,\r\n                      queue: true,\r\n                      endpoint: _endpoint,\r\n                      fn_index,\r\n                      time: /* @__PURE__ */ new Date()\r\n                    });\r\n                    eventSource.close();\r\n                  }\r\n                } else if (type === \"complete\") {\r\n                  complete = status;\r\n                } else if (type === \"log\") {\r\n                  fire_event({\r\n                    type: \"log\",\r\n                    log: data2.log,\r\n                    level: data2.level,\r\n                    endpoint: _endpoint,\r\n                    fn_index\r\n                  });\r\n                } else if (type === \"generating\") {\r\n                  fire_event({\r\n                    type: \"status\",\r\n                    time: /* @__PURE__ */ new Date(),\r\n                    ...status,\r\n                    stage: status == null ? void 0 : status.stage,\r\n                    queue: true,\r\n                    endpoint: _endpoint,\r\n                    fn_index\r\n                  });\r\n                }\r\n                if (data2) {\r\n                  fire_event({\r\n                    type: \"data\",\r\n                    time: /* @__PURE__ */ new Date(),\r\n                    data: transform_files ? transform_output(\r\n                      data2.data,\r\n                      api_info,\r\n                      config.root,\r\n                      config.root_url\r\n                    ) : data2.data,\r\n                    endpoint: _endpoint,\r\n                    fn_index\r\n                  });\r\n                  if (complete) {\r\n                    fire_event({\r\n                      type: \"status\",\r\n                      time: /* @__PURE__ */ new Date(),\r\n                      ...complete,\r\n                      stage: status == null ? void 0 : status.stage,\r\n                      queue: true,\r\n                      endpoint: _endpoint,\r\n                      fn_index\r\n                    });\r\n                    eventSource.close();\r\n                  }\r\n                }\r\n              };\r\n            } else if (protocol == \"sse_v1\") {\r\n              fire_event({\r\n                type: \"status\",\r\n                stage: \"pending\",\r\n                queue: true,\r\n                endpoint: _endpoint,\r\n                fn_index,\r\n                time: /* @__PURE__ */ new Date()\r\n              });\r\n              post_data2(\r\n                `${config.root}/queue/join?${url_params}`,\r\n                {\r\n                  ...payload,\r\n                  session_hash\r\n                },\r\n                hf_token\r\n              ).then(([response, status]) => {\r\n                if (status === 503) {\r\n                  fire_event({\r\n                    type: \"status\",\r\n                    stage: \"error\",\r\n                    message: QUEUE_FULL_MSG,\r\n                    queue: true,\r\n                    endpoint: _endpoint,\r\n                    fn_index,\r\n                    time: /* @__PURE__ */ new Date()\r\n                  });\r\n                } else if (status !== 200) {\r\n                  fire_event({\r\n                    type: \"status\",\r\n                    stage: \"error\",\r\n                    message: BROKEN_CONNECTION_MSG,\r\n                    queue: true,\r\n                    endpoint: _endpoint,\r\n                    fn_index,\r\n                    time: /* @__PURE__ */ new Date()\r\n                  });\r\n                } else {\r\n                  event_id = response.event_id;\r\n                  let callback = async function(_data) {\r\n                    try {\r\n                      const { type, status: status2, data: data2 } = handle_message(\r\n                        _data,\r\n                        last_status[fn_index]\r\n                      );\r\n                      if (type == \"heartbeat\") {\r\n                        return;\r\n                      }\r\n                      if (type === \"update\" && status2 && !complete) {\r\n                        fire_event({\r\n                          type: \"status\",\r\n                          endpoint: _endpoint,\r\n                          fn_index,\r\n                          time: /* @__PURE__ */ new Date(),\r\n                          ...status2\r\n                        });\r\n                      } else if (type === \"complete\") {\r\n                        complete = status2;\r\n                      } else if (type == \"unexpected_error\") {\r\n                        console.error(\"Unexpected error\", status2 == null ? void 0 : status2.message);\r\n                        fire_event({\r\n                          type: \"status\",\r\n                          stage: \"error\",\r\n                          message: (status2 == null ? void 0 : status2.message) || \"An Unexpected Error Occurred!\",\r\n                          queue: true,\r\n                          endpoint: _endpoint,\r\n                          fn_index,\r\n                          time: /* @__PURE__ */ new Date()\r\n                        });\r\n                      } else if (type === \"log\") {\r\n                        fire_event({\r\n                          type: \"log\",\r\n                          log: data2.log,\r\n                          level: data2.level,\r\n                          endpoint: _endpoint,\r\n                          fn_index\r\n                        });\r\n                        return;\r\n                      } else if (type === \"generating\") {\r\n                        fire_event({\r\n                          type: \"status\",\r\n                          time: /* @__PURE__ */ new Date(),\r\n                          ...status2,\r\n                          stage: status2 == null ? void 0 : status2.stage,\r\n                          queue: true,\r\n                          endpoint: _endpoint,\r\n                          fn_index\r\n                        });\r\n                      }\r\n                      if (data2) {\r\n                        fire_event({\r\n                          type: \"data\",\r\n                          time: /* @__PURE__ */ new Date(),\r\n                          data: transform_files ? transform_output(\r\n                            data2.data,\r\n                            api_info,\r\n                            config.root,\r\n                            config.root_url\r\n                          ) : data2.data,\r\n                          endpoint: _endpoint,\r\n                          fn_index\r\n                        });\r\n                        if (complete) {\r\n                          fire_event({\r\n                            type: \"status\",\r\n                            time: /* @__PURE__ */ new Date(),\r\n                            ...complete,\r\n                            stage: status2 == null ? void 0 : status2.stage,\r\n                            queue: true,\r\n                            endpoint: _endpoint,\r\n                            fn_index\r\n                          });\r\n                        }\r\n                      }\r\n                      if ((status2 == null ? void 0 : status2.stage) === \"complete\" || (status2 == null ? void 0 : status2.stage) === \"error\") {\r\n                        if (event_callbacks[event_id]) {\r\n                          delete event_callbacks[event_id];\r\n                        }\r\n                      }\r\n                    } catch (e) {\r\n                      console.error(\"Unexpected client exception\", e);\r\n                      fire_event({\r\n                        type: \"status\",\r\n                        stage: \"error\",\r\n                        message: \"An Unexpected Error Occurred!\",\r\n                        queue: true,\r\n                        endpoint: _endpoint,\r\n                        fn_index,\r\n                        time: /* @__PURE__ */ new Date()\r\n                      });\r\n                      close_stream();\r\n                    }\r\n                  };\r\n                  if (event_id in pending_stream_messages) {\r\n                    pending_stream_messages[event_id].forEach(\r\n                      (msg) => callback(msg)\r\n                    );\r\n                    delete pending_stream_messages[event_id];\r\n                  }\r\n                  event_callbacks[event_id] = callback;\r\n                  unclosed_events.add(event_id);\r\n                  if (!stream_open) {\r\n                    open_stream();\r\n                  }\r\n                }\r\n              });\r\n            }\r\n          }\r\n        );\r\n        function fire_event(event) {\r\n          const narrowed_listener_map = listener_map;\r\n          const listeners = narrowed_listener_map[event.type] || [];\r\n          listeners == null ? void 0 : listeners.forEach((l) => l(event));\r\n        }\r\n        function on(eventType, listener) {\r\n          const narrowed_listener_map = listener_map;\r\n          const listeners = narrowed_listener_map[eventType] || [];\r\n          narrowed_listener_map[eventType] = listeners;\r\n          listeners == null ? void 0 : listeners.push(listener);\r\n          return { on, off, cancel, destroy };\r\n        }\r\n        function off(eventType, listener) {\r\n          const narrowed_listener_map = listener_map;\r\n          let listeners = narrowed_listener_map[eventType] || [];\r\n          listeners = listeners == null ? void 0 : listeners.filter((l) => l !== listener);\r\n          narrowed_listener_map[eventType] = listeners;\r\n          return { on, off, cancel, destroy };\r\n        }\r\n        async function cancel() {\r\n          const _status = {\r\n            stage: \"complete\",\r\n            queue: false,\r\n            time: /* @__PURE__ */ new Date()\r\n          };\r\n          complete = _status;\r\n          fire_event({\r\n            ..._status,\r\n            type: \"status\",\r\n            endpoint: _endpoint,\r\n            fn_index\r\n          });\r\n          let cancel_request = {};\r\n          if (protocol === \"ws\") {\r\n            if (websocket && websocket.readyState === 0) {\r\n              websocket.addEventListener(\"open\", () => {\r\n                websocket.close();\r\n              });\r\n            } else {\r\n              websocket.close();\r\n            }\r\n            cancel_request = { fn_index, session_hash };\r\n          } else {\r\n            eventSource.close();\r\n            cancel_request = { event_id };\r\n          }\r\n          try {\r\n            await fetch_implementation(`${config.root}/reset`, {\r\n              headers: { \"Content-Type\": \"application/json\" },\r\n              method: \"POST\",\r\n              body: JSON.stringify(cancel_request)\r\n            });\r\n          } catch (e) {\r\n            console.warn(\r\n              \"The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable.\"\r\n            );\r\n          }\r\n        }\r\n        function destroy() {\r\n          for (const event_type in listener_map) {\r\n            listener_map[event_type].forEach((fn2) => {\r\n              off(event_type, fn2);\r\n            });\r\n          }\r\n        }\r\n        return {\r\n          on,\r\n          off,\r\n          cancel,\r\n          destroy\r\n        };\r\n      }\r\n      function open_stream() {\r\n        stream_open = true;\r\n        let params = new URLSearchParams({\r\n          session_hash\r\n        }).toString();\r\n        let url = new URL(`${config.root}/queue/data?${params}`);\r\n        event_stream = EventSource_factory(url);\r\n        event_stream.onmessage = async function(event) {\r\n          let _data = JSON.parse(event.data);\r\n          const event_id = _data.event_id;\r\n          if (!event_id) {\r\n            await Promise.all(\r\n              Object.keys(event_callbacks).map(\r\n                (event_id2) => event_callbacks[event_id2](_data)\r\n              )\r\n            );\r\n          } else if (event_callbacks[event_id]) {\r\n            if (_data.msg === \"process_completed\") {\r\n              unclosed_events.delete(event_id);\r\n              if (unclosed_events.size === 0) {\r\n                close_stream();\r\n              }\r\n            }\r\n            let fn2 = event_callbacks[event_id];\r\n            window.setTimeout(fn2, 0, _data);\r\n          } else {\r\n            if (!pending_stream_messages[event_id]) {\r\n              pending_stream_messages[event_id] = [];\r\n            }\r\n            pending_stream_messages[event_id].push(_data);\r\n          }\r\n        };\r\n        event_stream.onerror = async function(event) {\r\n          await Promise.all(\r\n            Object.keys(event_callbacks).map(\r\n              (event_id) => event_callbacks[event_id]({\r\n                msg: \"unexpected_error\",\r\n                message: BROKEN_CONNECTION_MSG\r\n              })\r\n            )\r\n          );\r\n          close_stream();\r\n        };\r\n      }\r\n      function close_stream() {\r\n        stream_open = false;\r\n        event_stream == null ? void 0 : event_stream.close();\r\n      }\r\n      async function component_server(component_id, fn_name, data) {\r\n        var _a;\r\n        const headers = { \"Content-Type\": \"application/json\" };\r\n        if (hf_token) {\r\n          headers.Authorization = `Bearer ${hf_token}`;\r\n        }\r\n        let root_url;\r\n        let component = config.components.find(\r\n          (comp) => comp.id === component_id\r\n        );\r\n        if ((_a = component == null ? void 0 : component.props) == null ? void 0 : _a.root_url) {\r\n          root_url = component.props.root_url;\r\n        } else {\r\n          root_url = config.root;\r\n        }\r\n        const response = await fetch_implementation(\r\n          `${root_url}/component_server/`,\r\n          {\r\n            method: \"POST\",\r\n            body: JSON.stringify({\r\n              data,\r\n              component_id,\r\n              fn_name,\r\n              session_hash\r\n            }),\r\n            headers\r\n          }\r\n        );\r\n        if (!response.ok) {\r\n          throw new Error(\r\n            \"Could not connect to component server: \" + response.statusText\r\n          );\r\n        }\r\n        const output = await response.json();\r\n        return output;\r\n      }\r\n      async function view_api(config2) {\r\n        if (api)\r\n          return api;\r\n        const headers = { \"Content-Type\": \"application/json\" };\r\n        if (hf_token) {\r\n          headers.Authorization = `Bearer ${hf_token}`;\r\n        }\r\n        let response;\r\n        if (semiver(config2.version || \"2.0.0\", \"3.30\") < 0) {\r\n          response = await fetch_implementation(\r\n            \"https://gradio-space-api-fetcher-v2.hf.space/api\",\r\n            {\r\n              method: \"POST\",\r\n              body: JSON.stringify({\r\n                serialize: false,\r\n                config: JSON.stringify(config2)\r\n              }),\r\n              headers\r\n            }\r\n          );\r\n        } else {\r\n          response = await fetch_implementation(`${config2.root}/info`, {\r\n            headers\r\n          });\r\n        }\r\n        if (!response.ok) {\r\n          throw new Error(BROKEN_CONNECTION_MSG);\r\n        }\r\n        let api_info = await response.json();\r\n        if (\"api\" in api_info) {\r\n          api_info = api_info.api;\r\n        }\r\n        if (api_info.named_endpoints[\"/predict\"] && !api_info.unnamed_endpoints[\"0\"]) {\r\n          api_info.unnamed_endpoints[0] = api_info.named_endpoints[\"/predict\"];\r\n        }\r\n        const x = transform_api_info(api_info, config2, api_map);\r\n        return x;\r\n      }\r\n    });\r\n  }\r\n  async function handle_blob2(endpoint, data, api_info, token) {\r\n    const blob_refs = await walk_and_store_blobs(\r\n      data,\r\n      void 0,\r\n      [],\r\n      true,\r\n      api_info\r\n    );\r\n    return Promise.all(\r\n      blob_refs.map(async ({ path, blob, type }) => {\r\n        if (blob) {\r\n          const file_url = (await upload_files2(endpoint, [blob], token)).files[0];\r\n          return { path, file_url, type, name: blob == null ? void 0 : blob.name };\r\n        }\r\n        return { path, type };\r\n      })\r\n    ).then((r) => {\r\n      r.forEach(({ path, file_url, type, name }) => {\r\n        if (type === \"Gallery\") {\r\n          update_object(data, file_url, path);\r\n        } else if (file_url) {\r\n          const file = new FileData({ path: file_url, orig_name: name });\r\n          update_object(data, file, path);\r\n        }\r\n      });\r\n      return data;\r\n    });\r\n  }\r\n}\r\nconst { post_data, upload_files, client, handle_blob } = api_factory(\r\n  fetch,\r\n  (...args) => new EventSource(...args)\r\n);\r\nfunction transform_output(data, api_info, root_url, remote_url) {\r\n  return data.map((d, i) => {\r\n    var _a, _b, _c, _d;\r\n    if (((_b = (_a = api_info == null ? void 0 : api_info.returns) == null ? void 0 : _a[i]) == null ? void 0 : _b.component) === \"File\") {\r\n      return normalise_file(d, root_url, remote_url);\r\n    } else if (((_d = (_c = api_info == null ? void 0 : api_info.returns) == null ? void 0 : _c[i]) == null ? void 0 : _d.component) === \"Gallery\") {\r\n      return d.map((img) => {\r\n        return Array.isArray(img) ? [normalise_file(img[0], root_url, remote_url), img[1]] : [normalise_file(img, root_url, remote_url), null];\r\n      });\r\n    } else if (typeof d === \"object\" && d.path) {\r\n      return normalise_file(d, root_url, remote_url);\r\n    }\r\n    return d;\r\n  });\r\n}\r\nfunction get_type(type, component, serializer, signature_type) {\r\n  switch (type.type) {\r\n    case \"string\":\r\n      return \"string\";\r\n    case \"boolean\":\r\n      return \"boolean\";\r\n    case \"number\":\r\n      return \"number\";\r\n  }\r\n  if (serializer === \"JSONSerializable\" || serializer === \"StringSerializable\") {\r\n    return \"any\";\r\n  } else if (serializer === \"ListStringSerializable\") {\r\n    return \"string[]\";\r\n  } else if (component === \"Image\") {\r\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : \"string\";\r\n  } else if (serializer === \"FileSerializable\") {\r\n    if ((type == null ? void 0 : type.type) === \"array\") {\r\n      return signature_type === \"parameter\" ? \"(Blob | File | Buffer)[]\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]`;\r\n    }\r\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}`;\r\n  } else if (serializer === \"GallerySerializable\") {\r\n    return signature_type === \"parameter\" ? \"[(Blob | File | Buffer), (string | null)][]\" : `[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]`;\r\n  }\r\n}\r\nfunction get_description(type, serializer) {\r\n  if (serializer === \"GallerySerializable\") {\r\n    return \"array of [file, label] tuples\";\r\n  } else if (serializer === \"ListStringSerializable\") {\r\n    return \"array of strings\";\r\n  } else if (serializer === \"FileSerializable\") {\r\n    return \"array of files or single file\";\r\n  }\r\n  return type.description;\r\n}\r\nfunction transform_api_info(api_info, config, api_map) {\r\n  const new_data = {\r\n    named_endpoints: {},\r\n    unnamed_endpoints: {}\r\n  };\r\n  for (const key in api_info) {\r\n    const cat = api_info[key];\r\n    for (const endpoint in cat) {\r\n      const dep_index = config.dependencies[endpoint] ? endpoint : api_map[endpoint.replace(\"/\", \"\")];\r\n      const info = cat[endpoint];\r\n      new_data[key][endpoint] = {};\r\n      new_data[key][endpoint].parameters = {};\r\n      new_data[key][endpoint].returns = {};\r\n      new_data[key][endpoint].type = config.dependencies[dep_index].types;\r\n      new_data[key][endpoint].parameters = info.parameters.map(\r\n        ({ label, component, type, serializer }) => ({\r\n          label,\r\n          component,\r\n          type: get_type(type, component, serializer, \"parameter\"),\r\n          description: get_description(type, serializer)\r\n        })\r\n      );\r\n      new_data[key][endpoint].returns = info.returns.map(\r\n        ({ label, component, type, serializer }) => ({\r\n          label,\r\n          component,\r\n          type: get_type(type, component, serializer, \"return\"),\r\n          description: get_description(type, serializer)\r\n        })\r\n      );\r\n    }\r\n  }\r\n  return new_data;\r\n}\r\nasync function get_jwt(space, token) {\r\n  try {\r\n    const r = await fetch(`https://huggingface.co/api/spaces/${space}/jwt`, {\r\n      headers: {\r\n        Authorization: `Bearer ${token}`\r\n      }\r\n    });\r\n    const jwt = (await r.json()).token;\r\n    return jwt || false;\r\n  } catch (e) {\r\n    console.error(e);\r\n    return false;\r\n  }\r\n}\r\nfunction update_object(object, newValue, stack) {\r\n  while (stack.length > 1) {\r\n    object = object[stack.shift()];\r\n  }\r\n  object[stack.shift()] = newValue;\r\n}\r\nasync function walk_and_store_blobs(param, type = void 0, path = [], root = false, api_info = void 0) {\r\n  if (Array.isArray(param)) {\r\n    let blob_refs = [];\r\n    await Promise.all(\r\n      param.map(async (v, i) => {\r\n        var _a;\r\n        let new_path = path.slice();\r\n        new_path.push(i);\r\n        const array_refs = await walk_and_store_blobs(\r\n          param[i],\r\n          root ? ((_a = api_info == null ? void 0 : api_info.parameters[i]) == null ? void 0 : _a.component) || void 0 : type,\r\n          new_path,\r\n          false,\r\n          api_info\r\n        );\r\n        blob_refs = blob_refs.concat(array_refs);\r\n      })\r\n    );\r\n    return blob_refs;\r\n  } else if (globalThis.Buffer && param instanceof globalThis.Buffer) {\r\n    const is_image = type === \"Image\";\r\n    return [\r\n      {\r\n        path,\r\n        blob: is_image ? false : new NodeBlob([param]),\r\n        type\r\n      }\r\n    ];\r\n  } else if (typeof param === \"object\") {\r\n    let blob_refs = [];\r\n    for (let key in param) {\r\n      if (param.hasOwnProperty(key)) {\r\n        let new_path = path.slice();\r\n        new_path.push(key);\r\n        blob_refs = blob_refs.concat(\r\n          await walk_and_store_blobs(\r\n            param[key],\r\n            void 0,\r\n            new_path,\r\n            false,\r\n            api_info\r\n          )\r\n        );\r\n      }\r\n    }\r\n    return blob_refs;\r\n  }\r\n  return [];\r\n}\r\nfunction skip_queue(id, config) {\r\n  var _a, _b, _c, _d;\r\n  return !(((_b = (_a = config == null ? void 0 : config.dependencies) == null ? void 0 : _a[id]) == null ? void 0 : _b.queue) === null ? config.enable_queue : (_d = (_c = config == null ? void 0 : config.dependencies) == null ? void 0 : _c[id]) == null ? void 0 : _d.queue) || false;\r\n}\r\nasync function resolve_config(fetch_implementation, endpoint, token) {\r\n  const headers = {};\r\n  if (token) {\r\n    headers.Authorization = `Bearer ${token}`;\r\n  }\r\n  if (typeof window !== \"undefined\" && window.gradio_config && location.origin !== \"http://localhost:9876\" && !window.gradio_config.dev_mode) {\r\n    const path = window.gradio_config.root;\r\n    const config = window.gradio_config;\r\n    config.root = resolve_root(endpoint, config.root, false);\r\n    return { ...config, path };\r\n  } else if (endpoint) {\r\n    let response = await fetch_implementation(`${endpoint}/config`, {\r\n      headers\r\n    });\r\n    if (response.status === 200) {\r\n      const config = await response.json();\r\n      config.path = config.path ?? \"\";\r\n      config.root = endpoint;\r\n      return config;\r\n    }\r\n    throw new Error(\"Could not get config.\");\r\n  }\r\n  throw new Error(\"No config or app endpoint found\");\r\n}\r\nasync function check_space_status(id, type, status_callback) {\r\n  let endpoint = type === \"subdomain\" ? `https://huggingface.co/api/spaces/by-subdomain/${id}` : `https://huggingface.co/api/spaces/${id}`;\r\n  let response;\r\n  let _status;\r\n  try {\r\n    response = await fetch(endpoint);\r\n    _status = response.status;\r\n    if (_status !== 200) {\r\n      throw new Error();\r\n    }\r\n    response = await response.json();\r\n  } catch (e) {\r\n    status_callback({\r\n      status: \"error\",\r\n      load_status: \"error\",\r\n      message: \"Could not get space status\",\r\n      detail: \"NOT_FOUND\"\r\n    });\r\n    return;\r\n  }\r\n  if (!response || _status !== 200)\r\n    return;\r\n  const {\r\n    runtime: { stage },\r\n    id: space_name\r\n  } = response;\r\n  switch (stage) {\r\n    case \"STOPPED\":\r\n    case \"SLEEPING\":\r\n      status_callback({\r\n        status: \"sleeping\",\r\n        load_status: \"pending\",\r\n        message: \"Space is asleep. Waking it up...\",\r\n        detail: stage\r\n      });\r\n      setTimeout(() => {\r\n        check_space_status(id, type, status_callback);\r\n      }, 1e3);\r\n      break;\r\n    case \"PAUSED\":\r\n      status_callback({\r\n        status: \"paused\",\r\n        load_status: \"error\",\r\n        message: \"This space has been paused by the author. If you would like to try this demo, consider duplicating the space.\",\r\n        detail: stage,\r\n        discussions_enabled: await discussions_enabled(space_name)\r\n      });\r\n      break;\r\n    case \"RUNNING\":\r\n    case \"RUNNING_BUILDING\":\r\n      status_callback({\r\n        status: \"running\",\r\n        load_status: \"complete\",\r\n        message: \"\",\r\n        detail: stage\r\n      });\r\n      break;\r\n    case \"BUILDING\":\r\n      status_callback({\r\n        status: \"building\",\r\n        load_status: \"pending\",\r\n        message: \"Space is building...\",\r\n        detail: stage\r\n      });\r\n      setTimeout(() => {\r\n        check_space_status(id, type, status_callback);\r\n      }, 1e3);\r\n      break;\r\n    default:\r\n      status_callback({\r\n        status: \"space_error\",\r\n        load_status: \"error\",\r\n        message: \"This space is experiencing an issue.\",\r\n        detail: stage,\r\n        discussions_enabled: await discussions_enabled(space_name)\r\n      });\r\n      break;\r\n  }\r\n}\r\nfunction handle_message(data, last_status) {\r\n  const queue = true;\r\n  switch (data.msg) {\r\n    case \"send_data\":\r\n      return { type: \"data\" };\r\n    case \"send_hash\":\r\n      return { type: \"hash\" };\r\n    case \"queue_full\":\r\n      return {\r\n        type: \"update\",\r\n        status: {\r\n          queue,\r\n          message: QUEUE_FULL_MSG,\r\n          stage: \"error\",\r\n          code: data.code,\r\n          success: data.success\r\n        }\r\n      };\r\n    case \"heartbeat\":\r\n      return {\r\n        type: \"heartbeat\"\r\n      };\r\n    case \"unexpected_error\":\r\n      return {\r\n        type: \"unexpected_error\",\r\n        status: {\r\n          queue,\r\n          message: data.message,\r\n          stage: \"error\",\r\n          success: false\r\n        }\r\n      };\r\n    case \"estimation\":\r\n      return {\r\n        type: \"update\",\r\n        status: {\r\n          queue,\r\n          stage: last_status || \"pending\",\r\n          code: data.code,\r\n          size: data.queue_size,\r\n          position: data.rank,\r\n          eta: data.rank_eta,\r\n          success: data.success\r\n        }\r\n      };\r\n    case \"progress\":\r\n      return {\r\n        type: \"update\",\r\n        status: {\r\n          queue,\r\n          stage: \"pending\",\r\n          code: data.code,\r\n          progress_data: data.progress_data,\r\n          success: data.success\r\n        }\r\n      };\r\n    case \"log\":\r\n      return { type: \"log\", data };\r\n    case \"process_generating\":\r\n      return {\r\n        type: \"generating\",\r\n        status: {\r\n          queue,\r\n          message: !data.success ? data.output.error : null,\r\n          stage: data.success ? \"generating\" : \"error\",\r\n          code: data.code,\r\n          progress_data: data.progress_data,\r\n          eta: data.average_duration\r\n        },\r\n        data: data.success ? data.output : null\r\n      };\r\n    case \"process_completed\":\r\n      if (\"error\" in data.output) {\r\n        return {\r\n          type: \"update\",\r\n          status: {\r\n            queue,\r\n            message: data.output.error,\r\n            stage: \"error\",\r\n            code: data.code,\r\n            success: data.success\r\n          }\r\n        };\r\n      }\r\n      return {\r\n        type: \"complete\",\r\n        status: {\r\n          queue,\r\n          message: !data.success ? data.output.error : void 0,\r\n          stage: data.success ? \"complete\" : \"error\",\r\n          code: data.code,\r\n          progress_data: data.progress_data\r\n        },\r\n        data: data.success ? data.output : null\r\n      };\r\n    case \"process_starts\":\r\n      return {\r\n        type: \"update\",\r\n        status: {\r\n          queue,\r\n          stage: \"pending\",\r\n          code: data.code,\r\n          size: data.rank,\r\n          position: 0,\r\n          success: data.success,\r\n          eta: data.eta\r\n        }\r\n      };\r\n  }\r\n  return { type: \"none\", status: { stage: \"error\", queue } };\r\n}\r\nexport {\r\n  FileData,\r\n  api_factory,\r\n  client,\r\n  duplicate,\r\n  get_fetchable_url_or_file,\r\n  normalise_file,\r\n  post_data,\r\n  prepare_files,\r\n  upload,\r\n  upload_files\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}