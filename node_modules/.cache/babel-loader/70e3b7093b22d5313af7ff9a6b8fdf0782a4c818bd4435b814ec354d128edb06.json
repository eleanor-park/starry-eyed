{"ast":null,"code":"import require$$0 from \"stream\";\nimport require$$0$1 from \"zlib\";\nimport require$$0$2 from \"buffer\";\nimport require$$3 from \"net\";\nimport require$$4 from \"tls\";\nimport require$$5 from \"crypto\";\nimport require$$0$3 from \"events\";\nimport require$$1$1 from \"https\";\nimport require$$2 from \"http\";\nimport require$$7 from \"url\";\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nfunction getAugmentedNamespace(n) {\n  if (n.__esModule) return n;\n  var f = n.default;\n  if (typeof f == \"function\") {\n    var a = function a2() {\n      if (this instanceof a2) {\n        var args = [null];\n        args.push.apply(args, arguments);\n        var Ctor = Function.bind.apply(f, args);\n        return new Ctor();\n      }\n      return f.apply(this, arguments);\n    };\n    a.prototype = f.prototype;\n  } else a = {};\n  Object.defineProperty(a, \"__esModule\", {\n    value: true\n  });\n  Object.keys(n).forEach(function (k) {\n    var d = Object.getOwnPropertyDescriptor(n, k);\n    Object.defineProperty(a, k, d.get ? d : {\n      enumerable: true,\n      get: function () {\n        return n[k];\n      }\n    });\n  });\n  return a;\n}\nconst {\n  Duplex\n} = require$$0;\nfunction emitClose$1(stream2) {\n  stream2.emit(\"close\");\n}\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\nfunction duplexOnError(err) {\n  this.removeListener(\"error\", duplexOnError);\n  this.destroy();\n  if (this.listenerCount(\"error\") === 0) {\n    this.emit(\"error\", err);\n  }\n}\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n  ws.on(\"message\", function message(msg, isBinary) {\n    const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n    if (!duplex.push(data)) ws.pause();\n  });\n  ws.once(\"error\", function error2(err) {\n    if (duplex.destroyed) return;\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n  ws.once(\"close\", function close() {\n    if (duplex.destroyed) return;\n    duplex.push(null);\n  });\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose$1, duplex);\n      return;\n    }\n    let called = false;\n    ws.once(\"error\", function error2(err2) {\n      called = true;\n      callback(err2);\n    });\n    ws.once(\"close\", function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose$1, duplex);\n    });\n    if (terminateOnDestroy) ws.terminate();\n  };\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once(\"open\", function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n    if (ws._socket === null) return;\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once(\"finish\", function finish() {\n        callback();\n      });\n      ws.close();\n    }\n  };\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once(\"open\", function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n    ws.send(chunk, callback);\n  };\n  duplex.on(\"end\", duplexOnEnd);\n  duplex.on(\"error\", duplexOnError);\n  return duplex;\n}\nvar stream = createWebSocketStream;\nconst stream$1 = /* @__PURE__ */getDefaultExportFromCjs(stream);\nvar bufferUtil$1 = {\n  exports: {}\n};\nvar constants = {\n  BINARY_TYPES: [\"nodebuffer\", \"arraybuffer\", \"fragments\"],\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\",\n  kForOnEventAttribute: Symbol(\"kIsForOnEventAttribute\"),\n  kListener: Symbol(\"kListener\"),\n  kStatusCode: Symbol(\"status-code\"),\n  kWebSocket: Symbol(\"websocket\"),\n  NOOP: () => {}\n};\nvar unmask$1;\nvar mask;\nconst {\n  EMPTY_BUFFER: EMPTY_BUFFER$3\n} = constants;\nconst FastBuffer$2 = Buffer[Symbol.species];\nfunction concat$1(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER$3;\n  if (list.length === 1) return list[0];\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n  if (offset < totalLength) {\n    return new FastBuffer$2(target.buffer, target.byteOffset, offset);\n  }\n  return target;\n}\nfunction _mask(source, mask2, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask2[i & 3];\n  }\n}\nfunction _unmask(buffer, mask2) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask2[i & 3];\n  }\n}\nfunction toArrayBuffer$1(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\nfunction toBuffer$2(data) {\n  toBuffer$2.readOnly = true;\n  if (Buffer.isBuffer(data)) return data;\n  let buf;\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer$2(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer$2.readOnly = false;\n  }\n  return buf;\n}\nbufferUtil$1.exports = {\n  concat: concat$1,\n  mask: _mask,\n  toArrayBuffer: toArrayBuffer$1,\n  toBuffer: toBuffer$2,\n  unmask: _unmask\n};\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil2 = require(\"bufferutil\");\n    mask = bufferUtil$1.exports.mask = function (source, mask2, output, offset, length) {\n      if (length < 48) _mask(source, mask2, output, offset, length);else bufferUtil2.mask(source, mask2, output, offset, length);\n    };\n    unmask$1 = bufferUtil$1.exports.unmask = function (buffer, mask2) {\n      if (buffer.length < 32) _unmask(buffer, mask2);else bufferUtil2.unmask(buffer, mask2);\n    };\n  } catch (e) {}\n}\nvar bufferUtilExports = bufferUtil$1.exports;\nconst kDone = Symbol(\"kDone\");\nconst kRun = Symbol(\"kRun\");\nlet Limiter$1 = class Limiter {\n  /**\r\n   * Creates a new `Limiter`.\r\n   *\r\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\r\n   *     to run concurrently\r\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n  /**\r\n   * Adds a job to the queue.\r\n   *\r\n   * @param {Function} job The job to run\r\n   * @public\r\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n  /**\r\n   * Removes a job from the queue and runs it if possible.\r\n   *\r\n   * @private\r\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n};\nvar limiter = Limiter$1;\nconst zlib = require$$0$1;\nconst bufferUtil = bufferUtilExports;\nconst Limiter2 = limiter;\nconst {\n  kStatusCode: kStatusCode$2\n} = constants;\nconst FastBuffer$1 = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0, 0, 255, 255]);\nconst kPerMessageDeflate = Symbol(\"permessage-deflate\");\nconst kTotalLength = Symbol(\"total-length\");\nconst kCallback = Symbol(\"callback\");\nconst kBuffers = Symbol(\"buffers\");\nconst kError$1 = Symbol(\"error\");\nlet zlibLimiter;\nlet PerMessageDeflate$4 = class PerMessageDeflate {\n  /**\r\n   * Creates a PerMessageDeflate instance.\r\n   *\r\n   * @param {Object} [options] Configuration options\r\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\r\n   *     for, or request, a custom client window size\r\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\r\n   *     acknowledge disabling of client context takeover\r\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\r\n   *     calls to zlib\r\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\r\n   *     use of a custom server window size\r\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\r\n   *     disabling of server context takeover\r\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\r\n   *     messages should not be compressed if context takeover is disabled\r\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\r\n   *     deflate\r\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\r\n   *     inflate\r\n   * @param {Boolean} [isServer=false] Create the instance in either server or\r\n   *     client mode\r\n   * @param {Number} [maxPayload=0] The maximum allowed message length\r\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n    this.params = null;\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;\n      zlibLimiter = new Limiter2(concurrency);\n    }\n  }\n  /**\r\n   * @type {String}\r\n   */\n  static get extensionName() {\n    return \"permessage-deflate\";\n  }\n  /**\r\n   * Create an extension negotiation offer.\r\n   *\r\n   * @return {Object} Extension parameters\r\n   * @public\r\n   */\n  offer() {\n    const params = {};\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n    return params;\n  }\n  /**\r\n   * Accept an extension negotiation offer/response.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Object} Accepted configuration\r\n   * @public\r\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n    return this.params;\n  }\n  /**\r\n   * Releases all resources used by the extension.\r\n   *\r\n   * @public\r\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n      this._deflate.close();\n      this._deflate = null;\n      if (callback) {\n        callback(new Error(\"The deflate stream was closed while data was being processed\"));\n      }\n    }\n  }\n  /**\r\n   *  Accept an extension negotiation offer.\r\n   *\r\n   * @param {Array} offers The extension negotiation offers\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find(params => {\n      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === \"number\" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\n        return false;\n      }\n      return true;\n    });\n    if (!accepted) {\n      throw new Error(\"None of the extension offers can be accepted\");\n    }\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === \"number\") {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === \"number\") {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n      delete accepted.client_max_window_bits;\n    }\n    return accepted;\n  }\n  /**\r\n   * Accept the extension negotiation response.\r\n   *\r\n   * @param {Array} response The extension negotiation response\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === \"number\") {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === \"number\" && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n      throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n    }\n    return params;\n  }\n  /**\r\n   * Normalize parameters.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Array} The offers/response with normalized parameters\r\n   * @private\r\n   */\n  normalizeParams(configurations) {\n    configurations.forEach(params => {\n      Object.keys(params).forEach(key => {\n        let value = params[key];\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n        value = value[0];\n        if (key === \"client_max_window_bits\") {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n        } else if (key === \"server_max_window_bits\") {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n          value = num;\n        } else if (key === \"client_no_context_takeover\" || key === \"server_no_context_takeover\") {\n          if (value !== true) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n        params[key] = value;\n      });\n    });\n    return configurations;\n  }\n  /**\r\n   * Decompress data. Concurrency limited.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add(done => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\r\n   * Compress data. Concurrency limited.\r\n   *\r\n   * @param {(Buffer|String)} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add(done => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\r\n   * Decompress data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? \"client\" : \"server\";\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on(\"error\", inflateOnError);\n      this._inflate.on(\"data\", inflateOnData);\n    }\n    this._inflate[kCallback] = callback;\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n    this._inflate.flush(() => {\n      const err = this._inflate[kError$1];\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n      const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n      callback(null, data2);\n    });\n  }\n  /**\r\n   * Compress data.\r\n   *\r\n   * @param {(Buffer|String)} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? \"server\" : \"client\";\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      this._deflate.on(\"data\", deflateOnData);\n    }\n    this._deflate[kCallback] = callback;\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        return;\n      }\n      let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n      if (fin) {\n        data2 = new FastBuffer$1(data2.buffer, data2.byteOffset, data2.length - 4);\n      }\n      this._deflate[kCallback] = null;\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n      callback(null, data2);\n    });\n  }\n};\nvar permessageDeflate = PerMessageDeflate$4;\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n  this[kError$1] = new RangeError(\"Max payload size exceeded\");\n  this[kError$1].code = \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\";\n  this[kError$1][kStatusCode$2] = 1009;\n  this.removeListener(\"data\", inflateOnData);\n  this.reset();\n}\nfunction inflateOnError(err) {\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode$2] = 1007;\n  this[kCallback](err);\n}\nvar validation = {\n  exports: {}\n};\nconst __viteOptionalPeerDep_utf8Validate_ws = {};\nconst __viteOptionalPeerDep_utf8Validate_ws$1 = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  default: __viteOptionalPeerDep_utf8Validate_ws\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nconst require$$1 = /* @__PURE__ */getAugmentedNamespace(__viteOptionalPeerDep_utf8Validate_ws$1);\nvar isValidUTF8_1;\nconst {\n  isUtf8\n} = require$$0$2;\nconst tokenChars$2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n// 0 - 15\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n// 16 - 31\n0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,\n// 32 - 47\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n// 48 - 63\n0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n// 64 - 79\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,\n// 80 - 95\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n// 96 - 111\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0\n// 112 - 127\n];\n\nfunction isValidStatusCode$2(code) {\n  return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;\n}\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n  while (i < len) {\n    if ((buf[i] & 128) === 0) {\n      i++;\n    } else if ((buf[i] & 224) === 192) {\n      if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {\n        return false;\n      }\n      i += 2;\n    } else if ((buf[i] & 240) === 224) {\n      if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 ||\n      // Overlong\n      buf[i] === 237 && (buf[i + 1] & 224) === 160) {\n        return false;\n      }\n      i += 3;\n    } else if ((buf[i] & 248) === 240) {\n      if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 ||\n      // Overlong\n      buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {\n        return false;\n      }\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nvalidation.exports = {\n  isValidStatusCode: isValidStatusCode$2,\n  isValidUTF8: _isValidUTF8,\n  tokenChars: tokenChars$2\n};\nif (isUtf8) {\n  isValidUTF8_1 = validation.exports.isValidUTF8 = function (buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF82 = require$$1;\n    isValidUTF8_1 = validation.exports.isValidUTF8 = function (buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF82(buf);\n    };\n  } catch (e) {}\n}\nvar validationExports = validation.exports;\nconst {\n  Writable\n} = require$$0;\nconst PerMessageDeflate$3 = permessageDeflate;\nconst {\n  BINARY_TYPES: BINARY_TYPES$1,\n  EMPTY_BUFFER: EMPTY_BUFFER$2,\n  kStatusCode: kStatusCode$1,\n  kWebSocket: kWebSocket$2\n} = constants;\nconst {\n  concat,\n  toArrayBuffer,\n  unmask\n} = bufferUtilExports;\nconst {\n  isValidStatusCode: isValidStatusCode$1,\n  isValidUTF8\n} = validationExports;\nconst FastBuffer = Buffer[Symbol.species];\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nlet Receiver$1 = class Receiver extends Writable {\n  /**\r\n   * Creates a Receiver instance.\r\n   *\r\n   * @param {Object} [options] Options object\r\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\r\n   * @param {Object} [options.extensions] An object containing the negotiated\r\n   *     extensions\r\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\r\n   *     client or server mode\r\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   */\n  constructor(options = {}) {\n    super();\n    this._binaryType = options.binaryType || BINARY_TYPES$1[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket$2] = void 0;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = void 0;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n  /**\r\n   * Implements `Writable.prototype._write()`.\r\n   *\r\n   * @param {Buffer} chunk The chunk of data to write\r\n   * @param {String} encoding The character encoding of `chunk`\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 8 && this._state == GET_INFO) return cb();\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n  /**\r\n   * Consumes `n` bytes from the buffered data.\r\n   *\r\n   * @param {Number} n The number of bytes to consume\r\n   * @return {Buffer} The consumed bytes\r\n   * @private\r\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n    if (n === this._buffers[0].length) return this._buffers.shift();\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n    const dst = Buffer.allocUnsafe(n);\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n      }\n      n -= buf.length;\n    } while (n > 0);\n    return dst;\n  }\n  /**\r\n   * Starts the parsing loop.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n    cb(err);\n  }\n  /**\r\n   * Reads the first two bytes of a frame.\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(2);\n    if ((buf[0] & 48) !== 0) {\n      this._loop = false;\n      return error(RangeError, \"RSV2 and RSV3 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_2_3\");\n    }\n    const compressed = (buf[0] & 64) === 64;\n    if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {\n      this._loop = false;\n      return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n    }\n    this._fin = (buf[0] & 128) === 128;\n    this._opcode = buf[0] & 15;\n    this._payloadLength = buf[1] & 127;\n    if (this._opcode === 0) {\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n      }\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(RangeError, \"invalid opcode 0\", true, 1002, \"WS_ERR_INVALID_OPCODE\");\n      }\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 1 || this._opcode === 2) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n      }\n      this._compressed = compressed;\n    } else if (this._opcode > 7 && this._opcode < 11) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(RangeError, \"FIN must be set\", true, 1002, \"WS_ERR_EXPECTED_FIN\");\n      }\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n      }\n      if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {\n        this._loop = false;\n        return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\");\n      }\n    } else {\n      this._loop = false;\n      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n    }\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 128) === 128;\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(RangeError, \"MASK must be set\", true, 1002, \"WS_ERR_EXPECTED_MASK\");\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(RangeError, \"MASK must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_MASK\");\n    }\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else return this.haveLength();\n  }\n  /**\r\n   * Gets extended payload length (7+16).\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n  /**\r\n   * Gets extended payload length (7+64).\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(RangeError, \"Unsupported WebSocket frame: payload length > 2^53 - 1\", false, 1009, \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\");\n    }\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n  /**\r\n   * Payload length has been read.\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 8) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\");\n      }\n    }\n    if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;\n  }\n  /**\r\n   * Reads mask bytes.\r\n   *\r\n   * @private\r\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n  /**\r\n   * Reads data bytes.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @return {(Error|RangeError|undefined)} A possible error\r\n   * @private\r\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER$2;\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n      data = this.consume(this._payloadLength);\n      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n        unmask(data, this._mask);\n      }\n    }\n    if (this._opcode > 7) return this.controlMessage(data);\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n    if (data.length) {\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n    return this.dataMessage();\n  }\n  /**\r\n   * Decompresses data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(error(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"));\n        }\n        this._fragments.push(buf);\n      }\n      const er = this.dataMessage();\n      if (er) return cb(er);\n      this.startLoop(cb);\n    });\n  }\n  /**\r\n   * Handles a data message.\r\n   *\r\n   * @return {(Error|undefined)} A possible error\r\n   * @private\r\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n      if (this._opcode === 2) {\n        let data;\n        if (this._binaryType === \"nodebuffer\") {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === \"arraybuffer\") {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n        this.emit(\"message\", data, true);\n      } else {\n        const buf = concat(fragments, messageLength);\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          this._loop = false;\n          return error(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n        }\n        this.emit(\"message\", buf, false);\n      }\n    }\n    this._state = GET_INFO;\n  }\n  /**\r\n   * Handles a control message.\r\n   *\r\n   * @param {Buffer} data Data to handle\r\n   * @return {(Error|RangeError|undefined)} A possible error\r\n   * @private\r\n   */\n  controlMessage(data) {\n    if (this._opcode === 8) {\n      this._loop = false;\n      if (data.length === 0) {\n        this.emit(\"conclude\", 1005, EMPTY_BUFFER$2);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n        if (!isValidStatusCode$1(code)) {\n          return error(RangeError, `invalid status code ${code}`, true, 1002, \"WS_ERR_INVALID_CLOSE_CODE\");\n        }\n        const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          return error(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n        }\n        this.emit(\"conclude\", code, buf);\n        this.end();\n      }\n    } else if (this._opcode === 9) {\n      this.emit(\"ping\", data);\n    } else {\n      this.emit(\"pong\", data);\n    }\n    this._state = GET_INFO;\n  }\n};\nvar receiver = Receiver$1;\nfunction error(ErrorCtor, message, prefix, statusCode, errorCode) {\n  const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n  Error.captureStackTrace(err, error);\n  err.code = errorCode;\n  err[kStatusCode$1] = statusCode;\n  return err;\n}\nconst receiver$1 = /* @__PURE__ */getDefaultExportFromCjs(receiver);\nconst {\n  randomFillSync\n} = require$$5;\nconst PerMessageDeflate$2 = permessageDeflate;\nconst {\n  EMPTY_BUFFER: EMPTY_BUFFER$1\n} = constants;\nconst {\n  isValidStatusCode\n} = validationExports;\nconst {\n  mask: applyMask,\n  toBuffer: toBuffer$1\n} = bufferUtilExports;\nconst kByteLength = Symbol(\"kByteLength\");\nconst maskBuffer = Buffer.alloc(4);\nlet Sender$1 = class Sender {\n  /**\r\n   * Creates a Sender instance.\r\n   *\r\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\r\n   * @param {Object} [extensions] An object containing the negotiated extensions\r\n   * @param {Function} [generateMask] The function used to generate the masking\r\n   *     key\r\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n  /**\r\n   * Frames a piece of data according to the HyBi WebSocket protocol.\r\n   *\r\n   * @param {(Buffer|String)} data The data to frame\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @return {(Buffer|String)[]} The framed data\r\n   * @public\r\n   */\n  static frame(data, options) {\n    let mask2;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n    if (options.mask) {\n      mask2 = options.maskBuffer || maskBuffer;\n      if (options.generateMask) {\n        options.generateMask(mask2);\n      } else {\n        randomFillSync(mask2, 0, 4);\n      }\n      skipMasking = (mask2[0] | mask2[1] | mask2[2] | mask2[3]) === 0;\n      offset = 6;\n    }\n    let dataLength;\n    if (typeof data === \"string\") {\n      if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n    let payloadLength = dataLength;\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n    target[0] = options.fin ? options.opcode | 128 : options.opcode;\n    if (options.rsv1) target[0] |= 64;\n    target[1] = payloadLength;\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n    if (!options.mask) return [target, data];\n    target[1] |= 128;\n    target[offset - 4] = mask2[0];\n    target[offset - 3] = mask2[1];\n    target[offset - 2] = mask2[2];\n    target[offset - 1] = mask2[3];\n    if (skipMasking) return [target, data];\n    if (merge) {\n      applyMask(data, mask2, target, offset, dataLength);\n      return [target];\n    }\n    applyMask(data, mask2, data, 0, dataLength);\n    return [target, data];\n  }\n  /**\r\n   * Sends a close message to the other peer.\r\n   *\r\n   * @param {Number} [code] The status code component of the body\r\n   * @param {(String|Buffer)} [data] The message component of the body\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */\n  close(code, data, mask2, cb) {\n    let buf;\n    if (code === void 0) {\n      buf = EMPTY_BUFFER$1;\n    } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n      throw new TypeError(\"First argument must be a valid error code number\");\n    } else if (data === void 0 || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n      if (length > 123) {\n        throw new RangeError(\"The message must not be greater than 123 bytes\");\n      }\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n      if (typeof data === \"string\") {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 8,\n      readOnly: false,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n  /**\r\n   * Sends a ping message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */\n  ping(data, mask2, cb) {\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (byteLength > 125) {\n      throw new RangeError(\"The data size must not be greater than 125 bytes\");\n    }\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 9,\n      readOnly,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n  /**\r\n   * Sends a pong message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */\n  pong(data, mask2, cb) {\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (byteLength > 125) {\n      throw new RangeError(\"The data size must not be greater than 125 bytes\");\n    }\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 10,\n      readOnly,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n  /**\r\n   * Sends a data message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\r\n   *     or text\r\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\r\n   *     compress `data`\r\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\r\n   *     last one\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n    if (options.fin) this._firstFragment = true;\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(Sender.frame(data, {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1: false\n      }), cb);\n    }\n  }\n  /**\r\n   * Dispatches a message.\r\n   *\r\n   * @param {(Buffer|String)} data The message to send\r\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\r\n   *     `data`\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\"The socket was closed while data was being compressed\");\n        if (typeof cb === \"function\") cb(err);\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n          if (typeof callback === \"function\") callback(err);\n        }\n        return;\n      }\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n  /**\r\n   * Executes queued send operations.\r\n   *\r\n   * @private\r\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n  /**\r\n   * Enqueues a send operation.\r\n   *\r\n   * @param {Array} params Send operation parameters.\r\n   * @private\r\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n  /**\r\n   * Sends a frame.\r\n   *\r\n   * @param {Buffer[]} list The frame to send\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n};\nvar sender = Sender$1;\nconst sender$1 = /* @__PURE__ */getDefaultExportFromCjs(sender);\nconst {\n  kForOnEventAttribute: kForOnEventAttribute$1,\n  kListener: kListener$1\n} = constants;\nconst kCode = Symbol(\"kCode\");\nconst kData = Symbol(\"kData\");\nconst kError = Symbol(\"kError\");\nconst kMessage = Symbol(\"kMessage\");\nconst kReason = Symbol(\"kReason\");\nconst kTarget = Symbol(\"kTarget\");\nconst kType = Symbol(\"kType\");\nconst kWasClean = Symbol(\"kWasClean\");\nclass Event {\n  /**\r\n   * Create a new `Event`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @throws {TypeError} If the `type` argument is not specified\r\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n  /**\r\n   * @type {*}\r\n   */\n  get target() {\n    return this[kTarget];\n  }\n  /**\r\n   * @type {String}\r\n   */\n  get type() {\n    return this[kType];\n  }\n}\nObject.defineProperty(Event.prototype, \"target\", {\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, \"type\", {\n  enumerable: true\n});\nclass CloseEvent extends Event {\n  /**\r\n   * Create a new `CloseEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {Number} [options.code=0] The status code explaining why the\r\n   *     connection was closed\r\n   * @param {String} [options.reason=''] A human-readable string explaining why\r\n   *     the connection was closed\r\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\r\n   *     connection was cleanly closed\r\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kCode] = options.code === void 0 ? 0 : options.code;\n    this[kReason] = options.reason === void 0 ? \"\" : options.reason;\n    this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;\n  }\n  /**\r\n   * @type {Number}\r\n   */\n  get code() {\n    return this[kCode];\n  }\n  /**\r\n   * @type {String}\r\n   */\n  get reason() {\n    return this[kReason];\n  }\n  /**\r\n   * @type {Boolean}\r\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\nObject.defineProperty(CloseEvent.prototype, \"code\", {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, \"reason\", {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, \"wasClean\", {\n  enumerable: true\n});\nclass ErrorEvent extends Event {\n  /**\r\n   * Create a new `ErrorEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {*} [options.error=null] The error that generated this event\r\n   * @param {String} [options.message=''] The error message\r\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kError] = options.error === void 0 ? null : options.error;\n    this[kMessage] = options.message === void 0 ? \"\" : options.message;\n  }\n  /**\r\n   * @type {*}\r\n   */\n  get error() {\n    return this[kError];\n  }\n  /**\r\n   * @type {String}\r\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\nObject.defineProperty(ErrorEvent.prototype, \"error\", {\n  enumerable: true\n});\nObject.defineProperty(ErrorEvent.prototype, \"message\", {\n  enumerable: true\n});\nclass MessageEvent extends Event {\n  /**\r\n   * Create a new `MessageEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {*} [options.data=null] The message content\r\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kData] = options.data === void 0 ? null : options.data;\n  }\n  /**\r\n   * @type {*}\r\n   */\n  get data() {\n    return this[kData];\n  }\n}\nObject.defineProperty(MessageEvent.prototype, \"data\", {\n  enumerable: true\n});\nconst EventTarget = {\n  /**\r\n   * Register an event listener.\r\n   *\r\n   * @param {String} type A string representing the event type to listen for\r\n   * @param {(Function|Object)} handler The listener to add\r\n   * @param {Object} [options] An options object specifies characteristics about\r\n   *     the event listener\r\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\r\n   *     listener should be invoked at most once after being added. If `true`,\r\n   *     the listener would be automatically removed when invoked.\r\n   * @public\r\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (!options[kForOnEventAttribute$1] && listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {\n        return;\n      }\n    }\n    let wrapper;\n    if (type === \"message\") {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent(\"message\", {\n          data: isBinary ? data : data.toString()\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"close\") {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent(\"close\", {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"error\") {\n      wrapper = function onError(error2) {\n        const event = new ErrorEvent(\"error\", {\n          error: error2,\n          message: error2.message\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"open\") {\n      wrapper = function onOpen() {\n        const event = new Event(\"open\");\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n    wrapper[kForOnEventAttribute$1] = !!options[kForOnEventAttribute$1];\n    wrapper[kListener$1] = handler;\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n  /**\r\n   * Remove an event listener.\r\n   *\r\n   * @param {String} type A string representing the event type to remove\r\n   * @param {(Function|Object)} handler The listener to remove\r\n   * @public\r\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\nvar eventTarget = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === \"object\" && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\nconst {\n  tokenChars: tokenChars$1\n} = validationExports;\nfunction push(dest, name, elem) {\n  if (dest[name] === void 0) dest[name] = [elem];else dest[name].push(elem);\n}\nfunction parse$2(header) {\n  const offers = /* @__PURE__ */Object.create(null);\n  let params = /* @__PURE__ */Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n    if (extensionName === void 0) {\n      if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1) start = i;\n      } else if (i !== 0 && (code === 32 || code === 9)) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 44) {\n          push(offers, name, params);\n          params = /* @__PURE__ */Object.create(null);\n        } else {\n          extensionName = name;\n        }\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === void 0) {\n      if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 32 || code === 9) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 44) {\n          push(offers, extensionName, params);\n          params = /* @__PURE__ */Object.create(null);\n          extensionName = void 0;\n        }\n        start = end = -1;\n      } else if (code === 61 && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      if (isEscaping) {\n        if (tokenChars$1[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars$1[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 34 && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 92) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 34 && header.charCodeAt(i - 1) === 61) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 32 || code === 9)) {\n        if (end === -1) end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, \"\");\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 44) {\n          push(offers, extensionName, params);\n          params = /* @__PURE__ */Object.create(null);\n          extensionName = void 0;\n        }\n        paramName = void 0;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n  if (start === -1 || inQuotes || code === 32 || code === 9) {\n    throw new SyntaxError(\"Unexpected end of input\");\n  }\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === void 0) {\n    push(offers, token, params);\n  } else {\n    if (paramName === void 0) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, \"\"));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n  return offers;\n}\nfunction format$1(extensions) {\n  return Object.keys(extensions).map(extension2 => {\n    let configurations = extensions[extension2];\n    if (!Array.isArray(configurations)) configurations = [configurations];\n    return configurations.map(params => {\n      return [extension2].concat(Object.keys(params).map(k => {\n        let values = params[k];\n        if (!Array.isArray(values)) values = [values];\n        return values.map(v => v === true ? k : `${k}=${v}`).join(\"; \");\n      })).join(\"; \");\n    }).join(\", \");\n  }).join(\", \");\n}\nvar extension$1 = {\n  format: format$1,\n  parse: parse$2\n};\nconst EventEmitter$1 = require$$0$3;\nconst https = require$$1$1;\nconst http$1 = require$$2;\nconst net = require$$3;\nconst tls = require$$4;\nconst {\n  randomBytes,\n  createHash: createHash$1\n} = require$$5;\nconst {\n  URL\n} = require$$7;\nconst PerMessageDeflate$1 = permessageDeflate;\nconst Receiver2 = receiver;\nconst Sender2 = sender;\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID: GUID$1,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket: kWebSocket$1,\n  NOOP\n} = constants;\nconst {\n  EventTarget: {\n    addEventListener,\n    removeEventListener\n  }\n} = eventTarget;\nconst {\n  format,\n  parse: parse$1\n} = extension$1;\nconst {\n  toBuffer\n} = bufferUtilExports;\nconst closeTimeout = 30 * 1e3;\nconst kAborted = Symbol(\"kAborted\");\nconst protocolVersions = [8, 13];\nconst readyStates = [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\nlet WebSocket$1 = class WebSocket extends EventEmitter$1 {\n  /**\r\n   * Create a new `WebSocket`.\r\n   *\r\n   * @param {(String|URL)} address The URL to which to connect\r\n   * @param {(String|String[])} [protocols] The subprotocols\r\n   * @param {Object} [options] Connection options\r\n   */\n  constructor(address, protocols, options) {\n    super();\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = \"\";\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n      if (protocols === void 0) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === \"object\" && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n  /**\r\n   * This deviates from the WHATWG interface since ws doesn't support the\r\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\r\n   * type).\r\n   *\r\n   * @type {String}\r\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n    this._binaryType = type;\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n  /**\r\n   * @type {Number}\r\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n  /**\r\n   * @type {String}\r\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n  /**\r\n   * @type {Boolean}\r\n   */\n  get isPaused() {\n    return this._paused;\n  }\n  /**\r\n   * @type {Function}\r\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n  /**\r\n   * @type {Function}\r\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n  /**\r\n   * @type {Function}\r\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n  /**\r\n   * @type {Function}\r\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n  /**\r\n   * @type {String}\r\n   */\n  get protocol() {\n    return this._protocol;\n  }\n  /**\r\n   * @type {Number}\r\n   */\n  get readyState() {\n    return this._readyState;\n  }\n  /**\r\n   * @type {String}\r\n   */\n  get url() {\n    return this._url;\n  }\n  /**\r\n   * Set up the socket and the internal resources.\r\n   *\r\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\r\n   *     server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Object} options Options object\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   * @private\r\n   */\n  setSocket(socket, head, options) {\n    const receiver2 = new Receiver2({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n    this._sender = new Sender2(socket, this._extensions, options.generateMask);\n    this._receiver = receiver2;\n    this._socket = socket;\n    receiver2[kWebSocket$1] = this;\n    socket[kWebSocket$1] = this;\n    receiver2.on(\"conclude\", receiverOnConclude);\n    receiver2.on(\"drain\", receiverOnDrain);\n    receiver2.on(\"error\", receiverOnError);\n    receiver2.on(\"message\", receiverOnMessage);\n    receiver2.on(\"ping\", receiverOnPing);\n    receiver2.on(\"pong\", receiverOnPong);\n    socket.setTimeout(0);\n    socket.setNoDelay();\n    if (head.length > 0) socket.unshift(head);\n    socket.on(\"close\", socketOnClose);\n    socket.on(\"data\", socketOnData);\n    socket.on(\"end\", socketOnEnd);\n    socket.on(\"error\", socketOnError$1);\n    this._readyState = WebSocket.OPEN;\n    this.emit(\"open\");\n  }\n  /**\r\n   * Emit the `'close'` event.\r\n   *\r\n   * @private\r\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit(\"close\", this._closeCode, this._closeMessage);\n      return;\n    }\n    if (this._extensions[PerMessageDeflate$1.extensionName]) {\n      this._extensions[PerMessageDeflate$1.extensionName].cleanup();\n    }\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit(\"close\", this._closeCode, this._closeMessage);\n  }\n  /**\r\n   * Start a closing handshake.\r\n   *\r\n   *          +----------+   +-----------+   +----------+\r\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\r\n   *    |     +----------+   +-----------+   +----------+     |\r\n   *          +----------+   +-----------+         |\r\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\r\n   *          +----------+   +-----------+   |\r\n   *    |           |                        |   +---+        |\r\n   *                +------------------------+-->|fin| - - - -\r\n   *    |         +---+                      |   +---+\r\n   *     - - - - -|fin|<---------------------+\r\n   *              +---+\r\n   *\r\n   * @param {Number} [code] Status code explaining why the connection is closing\r\n   * @param {(String|Buffer)} [data] The reason why the connection is\r\n   *     closing\r\n   * @public\r\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = \"WebSocket was closed before the connection was established\";\n      abortHandshake$1(this, this._req, msg);\n      return;\n    }\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n        this._socket.end();\n      }\n      return;\n    }\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, err => {\n      if (err) return;\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n        this._socket.end();\n      }\n    });\n    this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);\n  }\n  /**\r\n   * Pause the socket.\r\n   *\r\n   * @public\r\n   */\n  pause() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = true;\n    this._socket.pause();\n  }\n  /**\r\n   * Send a ping.\r\n   *\r\n   * @param {*} [data] The data to send\r\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when the ping is sent\r\n   * @public\r\n   */\n  ping(data, mask2, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof data === \"function\") {\n      cb = data;\n      data = mask2 = void 0;\n    } else if (typeof mask2 === \"function\") {\n      cb = mask2;\n      mask2 = void 0;\n    }\n    if (typeof data === \"number\") data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask2 === void 0) mask2 = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask2, cb);\n  }\n  /**\r\n   * Send a pong.\r\n   *\r\n   * @param {*} [data] The data to send\r\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when the pong is sent\r\n   * @public\r\n   */\n  pong(data, mask2, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof data === \"function\") {\n      cb = data;\n      data = mask2 = void 0;\n    } else if (typeof mask2 === \"function\") {\n      cb = mask2;\n      mask2 = void 0;\n    }\n    if (typeof data === \"number\") data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask2 === void 0) mask2 = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask2, cb);\n  }\n  /**\r\n   * Resume the socket.\r\n   *\r\n   * @public\r\n   */\n  resume() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n  /**\r\n   * Send a data message.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Object} [options] Options object\r\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\r\n   *     text\r\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\r\n   *     `data`\r\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\r\n   *     last one\r\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when data is written out\r\n   * @public\r\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof options === \"function\") {\n      cb = options;\n      options = {};\n    }\n    if (typeof data === \"number\") data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    const opts = {\n      binary: typeof data !== \"string\",\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n    if (!this._extensions[PerMessageDeflate$1.extensionName]) {\n      opts.compress = false;\n    }\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n  /**\r\n   * Forcibly close the connection.\r\n   *\r\n   * @public\r\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = \"WebSocket was closed before the connection was established\";\n      abortHandshake$1(this, this._req, msg);\n      return;\n    }\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n};\nObject.defineProperty(WebSocket$1, \"CONNECTING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CONNECTING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(WebSocket$1, \"OPEN\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"OPEN\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(WebSocket$1, \"CLOSING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CLOSING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(WebSocket$1, \"CLOSED\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSED\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CLOSED\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSED\")\n});\n[\"binaryType\", \"bufferedAmount\", \"extensions\", \"isPaused\", \"protocol\", \"readyState\", \"url\"].forEach(property => {\n  Object.defineProperty(WebSocket$1.prototype, property, {\n    enumerable: true\n  });\n});\n[\"open\", \"error\", \"close\", \"message\"].forEach(method => {\n  Object.defineProperty(WebSocket$1.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n      if (typeof handler !== \"function\") return;\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\nWebSocket$1.prototype.addEventListener = addEventListener;\nWebSocket$1.prototype.removeEventListener = removeEventListener;\nvar websocket = WebSocket$1;\nfunction initAsClient(websocket2, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: void 0,\n    socketPath: void 0,\n    hostname: void 0,\n    protocol: void 0,\n    timeout: void 0,\n    method: \"GET\",\n    host: void 0,\n    path: void 0,\n    port: void 0\n  };\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(\", \")})`);\n  }\n  let parsedUrl;\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket2._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n    websocket2._url = address;\n  }\n  const isSecure = parsedUrl.protocol === \"wss:\";\n  const isIpcUrl = parsedUrl.protocol === \"ws+unix:\";\n  let invalidUrlMessage;\n  if (parsedUrl.protocol !== \"ws:\" && !isSecure && !isIpcUrl) {\n    invalidUrlMessage = `The URL's protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"`;\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = \"The URL contains a fragment identifier\";\n  }\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n    if (websocket2._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket2, err);\n      return;\n    }\n  }\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString(\"base64\");\n  const request = isSecure ? https.request : http$1.request;\n  const protocolSet = /* @__PURE__ */new Set();\n  let perMessageDeflate;\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith(\"[\") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    \"Sec-WebSocket-Version\": opts.protocolVersion,\n    \"Sec-WebSocket-Key\": key,\n    Connection: \"Upgrade\",\n    Upgrade: \"websocket\"\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate$1(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n    opts.headers[\"Sec-WebSocket-Extensions\"] = format({\n      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (typeof protocol !== \"string\" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n        throw new SyntaxError(\"An invalid or duplicated subprotocol was specified\");\n      }\n      protocolSet.add(protocol);\n    }\n    opts.headers[\"Sec-WebSocket-Protocol\"] = protocols.join(\",\");\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers[\"Sec-WebSocket-Origin\"] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n  if (isIpcUrl) {\n    const parts = opts.path.split(\":\");\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n  let req;\n  if (opts.followRedirects) {\n    if (websocket2._redirects === 0) {\n      websocket2._originalIpc = isIpcUrl;\n      websocket2._originalSecure = isSecure;\n      websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n      const headers = options && options.headers;\n      options = {\n        ...options,\n        headers: {}\n      };\n      if (headers) {\n        for (const [key2, value] of Object.entries(headers)) {\n          options.headers[key2.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket2.listenerCount(\"redirect\") === 0) {\n      const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;\n      if (!isSameHost || websocket2._originalSecure && !isSecure) {\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n        if (!isSameHost) delete opts.headers.host;\n        opts.auth = void 0;\n      }\n    }\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization = \"Basic \" + Buffer.from(opts.auth).toString(\"base64\");\n    }\n    req = websocket2._req = request(opts);\n    if (websocket2._redirects) {\n      websocket2.emit(\"redirect\", websocket2.url, req);\n    }\n  } else {\n    req = websocket2._req = request(opts);\n  }\n  if (opts.timeout) {\n    req.on(\"timeout\", () => {\n      abortHandshake$1(websocket2, req, \"Opening handshake has timed out\");\n    });\n  }\n  req.on(\"error\", err => {\n    if (req === null || req[kAborted]) return;\n    req = websocket2._req = null;\n    emitErrorAndClose(websocket2, err);\n  });\n  req.on(\"response\", res => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket2._redirects > opts.maxRedirects) {\n        abortHandshake$1(websocket2, req, \"Maximum redirects exceeded\");\n        return;\n      }\n      req.abort();\n      let addr;\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket2, err);\n        return;\n      }\n      initAsClient(websocket2, addr, protocols, options);\n    } else if (!websocket2.emit(\"unexpected-response\", req, res)) {\n      abortHandshake$1(websocket2, req, `Unexpected server response: ${res.statusCode}`);\n    }\n  });\n  req.on(\"upgrade\", (res, socket, head) => {\n    websocket2.emit(\"upgrade\", res);\n    if (websocket2.readyState !== WebSocket$1.CONNECTING) return;\n    req = websocket2._req = null;\n    if (res.headers.upgrade.toLowerCase() !== \"websocket\") {\n      abortHandshake$1(websocket2, socket, \"Invalid Upgrade header\");\n      return;\n    }\n    const digest = createHash$1(\"sha1\").update(key + GUID$1).digest(\"base64\");\n    if (res.headers[\"sec-websocket-accept\"] !== digest) {\n      abortHandshake$1(websocket2, socket, \"Invalid Sec-WebSocket-Accept header\");\n      return;\n    }\n    const serverProt = res.headers[\"sec-websocket-protocol\"];\n    let protError;\n    if (serverProt !== void 0) {\n      if (!protocolSet.size) {\n        protError = \"Server sent a subprotocol but none was requested\";\n      } else if (!protocolSet.has(serverProt)) {\n        protError = \"Server sent an invalid subprotocol\";\n      }\n    } else if (protocolSet.size) {\n      protError = \"Server sent no subprotocol\";\n    }\n    if (protError) {\n      abortHandshake$1(websocket2, socket, protError);\n      return;\n    }\n    if (serverProt) websocket2._protocol = serverProt;\n    const secWebSocketExtensions = res.headers[\"sec-websocket-extensions\"];\n    if (secWebSocketExtensions !== void 0) {\n      if (!perMessageDeflate) {\n        const message = \"Server sent a Sec-WebSocket-Extensions header but no extension was requested\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      let extensions;\n      try {\n        extensions = parse$1(secWebSocketExtensions);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Extensions header\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      const extensionNames = Object.keys(extensions);\n      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {\n        const message = \"Server indicated an extension that was not requested\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate$1.extensionName]);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Extensions header\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      websocket2._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;\n    }\n    websocket2.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket2);\n  } else {\n    req.end();\n  }\n}\nfunction emitErrorAndClose(websocket2, err) {\n  websocket2._readyState = WebSocket$1.CLOSING;\n  websocket2.emit(\"error\", err);\n  websocket2.emitClose();\n}\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\nfunction tlsConnect(options) {\n  options.path = void 0;\n  if (!options.servername && options.servername !== \"\") {\n    options.servername = net.isIP(options.host) ? \"\" : options.host;\n  }\n  return tls.connect(options);\n}\nfunction abortHandshake$1(websocket2, stream2, message) {\n  websocket2._readyState = WebSocket$1.CLOSING;\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake$1);\n  if (stream2.setHeader) {\n    stream2[kAborted] = true;\n    stream2.abort();\n    if (stream2.socket && !stream2.socket.destroyed) {\n      stream2.socket.destroy();\n    }\n    process.nextTick(emitErrorAndClose, websocket2, err);\n  } else {\n    stream2.destroy(err);\n    stream2.once(\"error\", websocket2.emit.bind(websocket2, \"error\"));\n    stream2.once(\"close\", websocket2.emitClose.bind(websocket2));\n  }\n}\nfunction sendAfterClose(websocket2, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n    if (websocket2._socket) websocket2._sender._bufferedBytes += length;else websocket2._bufferedAmount += length;\n  }\n  if (cb) {\n    const err = new Error(`WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`);\n    process.nextTick(cb, err);\n  }\n}\nfunction receiverOnConclude(code, reason) {\n  const websocket2 = this[kWebSocket$1];\n  websocket2._closeFrameReceived = true;\n  websocket2._closeMessage = reason;\n  websocket2._closeCode = code;\n  if (websocket2._socket[kWebSocket$1] === void 0) return;\n  websocket2._socket.removeListener(\"data\", socketOnData);\n  process.nextTick(resume, websocket2._socket);\n  if (code === 1005) websocket2.close();else websocket2.close(code, reason);\n}\nfunction receiverOnDrain() {\n  const websocket2 = this[kWebSocket$1];\n  if (!websocket2.isPaused) websocket2._socket.resume();\n}\nfunction receiverOnError(err) {\n  const websocket2 = this[kWebSocket$1];\n  if (websocket2._socket[kWebSocket$1] !== void 0) {\n    websocket2._socket.removeListener(\"data\", socketOnData);\n    process.nextTick(resume, websocket2._socket);\n    websocket2.close(err[kStatusCode]);\n  }\n  websocket2.emit(\"error\", err);\n}\nfunction receiverOnFinish() {\n  this[kWebSocket$1].emitClose();\n}\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket$1].emit(\"message\", data, isBinary);\n}\nfunction receiverOnPing(data) {\n  const websocket2 = this[kWebSocket$1];\n  websocket2.pong(data, !websocket2._isServer, NOOP);\n  websocket2.emit(\"ping\", data);\n}\nfunction receiverOnPong(data) {\n  this[kWebSocket$1].emit(\"pong\", data);\n}\nfunction resume(stream2) {\n  stream2.resume();\n}\nfunction socketOnClose() {\n  const websocket2 = this[kWebSocket$1];\n  this.removeListener(\"close\", socketOnClose);\n  this.removeListener(\"data\", socketOnData);\n  this.removeListener(\"end\", socketOnEnd);\n  websocket2._readyState = WebSocket$1.CLOSING;\n  let chunk;\n  if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {\n    websocket2._receiver.write(chunk);\n  }\n  websocket2._receiver.end();\n  this[kWebSocket$1] = void 0;\n  clearTimeout(websocket2._closeTimer);\n  if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {\n    websocket2.emitClose();\n  } else {\n    websocket2._receiver.on(\"error\", receiverOnFinish);\n    websocket2._receiver.on(\"finish\", receiverOnFinish);\n  }\n}\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket$1]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\nfunction socketOnEnd() {\n  const websocket2 = this[kWebSocket$1];\n  websocket2._readyState = WebSocket$1.CLOSING;\n  websocket2._receiver.end();\n  this.end();\n}\nfunction socketOnError$1() {\n  const websocket2 = this[kWebSocket$1];\n  this.removeListener(\"error\", socketOnError$1);\n  this.on(\"error\", NOOP);\n  if (websocket2) {\n    websocket2._readyState = WebSocket$1.CLOSING;\n    this.destroy();\n  }\n}\nconst WebSocket$2 = /* @__PURE__ */getDefaultExportFromCjs(websocket);\nconst {\n  tokenChars\n} = validationExports;\nfunction parse(header) {\n  const protocols = /* @__PURE__ */new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (i !== 0 && (code === 32 || code === 9)) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 44) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n      if (end === -1) end = i;\n      const protocol2 = header.slice(start, end);\n      if (protocols.has(protocol2)) {\n        throw new SyntaxError(`The \"${protocol2}\" subprotocol is duplicated`);\n      }\n      protocols.add(protocol2);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError(\"Unexpected end of input\");\n  }\n  const protocol = header.slice(start, i);\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n  protocols.add(protocol);\n  return protocols;\n}\nvar subprotocol$1 = {\n  parse\n};\nconst EventEmitter = require$$0$3;\nconst http = require$$2;\nconst {\n  createHash\n} = require$$5;\nconst extension = extension$1;\nconst PerMessageDeflate2 = permessageDeflate;\nconst subprotocol = subprotocol$1;\nconst WebSocket2 = websocket;\nconst {\n  GUID,\n  kWebSocket\n} = constants;\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\nclass WebSocketServer extends EventEmitter {\n  /**\r\n   * Create a `WebSocketServer` instance.\r\n   *\r\n   * @param {Object} options Configuration options\r\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\r\n   *     pending connections\r\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\r\n   *     track clients\r\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\r\n   * @param {String} [options.host] The hostname where to bind the server\r\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\r\n   *     size\r\n   * @param {Boolean} [options.noServer=false] Enable no server mode\r\n   * @param {String} [options.path] Accept only connections matching this path\r\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\r\n   *     permessage-deflate\r\n   * @param {Number} [options.port] The port where to bind the server\r\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\r\n   *     server to use\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   * @param {Function} [options.verifyClient] A hook to reject connections\r\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\r\n   *     class to use. It must be the `WebSocket` class or class that extends it\r\n   * @param {Function} [callback] A listener for the `listening` event\r\n   */\n  constructor(options, callback) {\n    super();\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket: WebSocket2,\n      ...options\n    };\n    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n      throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options must be specified');\n    }\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          \"Content-Length\": body.length,\n          \"Content-Type\": \"text/plain\"\n        });\n        res.end(body);\n      });\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, \"connection\");\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, \"listening\"),\n        error: this.emit.bind(this, \"error\"),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = /* @__PURE__ */new Set();\n      this._shouldEmitClose = false;\n    }\n    this.options = options;\n    this._state = RUNNING;\n  }\n  /**\r\n   * Returns the bound address, the address family name, and port of the server\r\n   * as reported by the operating system if listening on an IP socket.\r\n   * If the server is listening on a pipe or UNIX domain socket, the name is\r\n   * returned as a string.\r\n   *\r\n   * @return {(Object|String|null)} The address of the server\r\n   * @public\r\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n    if (!this._server) return null;\n    return this._server.address();\n  }\n  /**\r\n   * Stop the server from accepting new connections and emit the `'close'` event\r\n   * when all existing connections are closed.\r\n   *\r\n   * @param {Function} [cb] A one-time listener for the `'close'` event\r\n   * @public\r\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once(\"close\", () => {\n          cb(new Error(\"The server is not running\"));\n        });\n      }\n      process.nextTick(emitClose, this);\n      return;\n    }\n    if (cb) this.once(\"close\", cb);\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n  /**\r\n   * See if a given request should be handled by this server instance.\r\n   *\r\n   * @param {http.IncomingMessage} req Request object to inspect\r\n   * @return {Boolean} `true` if the request is valid, else `false`\r\n   * @public\r\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf(\"?\");\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n      if (pathname !== this.options.path) return false;\n    }\n    return true;\n  }\n  /**\r\n   * Handle a HTTP Upgrade request.\r\n   *\r\n   * @param {http.IncomingMessage} req The request object\r\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\r\n   *     server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Function} cb Callback\r\n   * @public\r\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on(\"error\", socketOnError);\n    const key = req.headers[\"sec-websocket-key\"];\n    const version = +req.headers[\"sec-websocket-version\"];\n    if (req.method !== \"GET\") {\n      const message = \"Invalid HTTP method\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n    if (req.headers.upgrade.toLowerCase() !== \"websocket\") {\n      const message = \"Invalid Upgrade header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!key || !keyRegex.test(key)) {\n      const message = \"Missing or invalid Sec-WebSocket-Key header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (version !== 8 && version !== 13) {\n      const message = \"Missing or invalid Sec-WebSocket-Version header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n    const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n    let protocols = /* @__PURE__ */new Set();\n    if (secWebSocketProtocol !== void 0) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Protocol header\";\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n    const secWebSocketExtensions = req.headers[\"sec-websocket-extensions\"];\n    const extensions = {};\n    if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {\n      const perMessageDeflate = new PerMessageDeflate2(this.options.perMessageDeflate, true, this.options.maxPayload);\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n        if (offers[PerMessageDeflate2.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate2.extensionName]);\n          extensions[PerMessageDeflate2.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message = \"Invalid or unacceptable Sec-WebSocket-Extensions header\";\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n          this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n        });\n        return;\n      }\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n  /**\r\n   * Upgrade the connection to WebSocket.\r\n   *\r\n   * @param {Object} extensions The accepted extensions\r\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\r\n   * @param {Set} protocols The subprotocols\r\n   * @param {http.IncomingMessage} req The request object\r\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\r\n   *     server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Function} cb Callback\r\n   * @throws {Error} If called more than once with the same socket\r\n   * @private\r\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    if (!socket.readable || !socket.writable) return socket.destroy();\n    if (socket[kWebSocket]) {\n      throw new Error(\"server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration\");\n    }\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n    const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n    const headers = [\"HTTP/1.1 101 Switching Protocols\", \"Upgrade: websocket\", \"Connection: Upgrade\", `Sec-WebSocket-Accept: ${digest}`];\n    const ws = new this.options.WebSocket(null);\n    if (protocols.size) {\n      const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n    if (extensions[PerMessageDeflate2.extensionName]) {\n      const params = extensions[PerMessageDeflate2.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate2.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n    this.emit(\"headers\", headers, req);\n    socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\n    socket.removeListener(\"error\", socketOnError);\n    ws.setSocket(socket, head, {\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on(\"close\", () => {\n        this.clients.delete(ws);\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n    cb(ws, req);\n  }\n}\nvar websocketServer = WebSocketServer;\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit(\"close\");\n}\nfunction socketOnError() {\n  this.destroy();\n}\nfunction abortHandshake(socket, code, message, headers) {\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: \"close\",\n    \"Content-Type\": \"text/html\",\n    \"Content-Length\": Buffer.byteLength(message),\n    ...headers\n  };\n  socket.once(\"finish\", socket.destroy);\n  socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\n` + Object.keys(headers).map(h => `${h}: ${headers[h]}`).join(\"\\r\\n\") + \"\\r\\n\\r\\n\" + message);\n}\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount(\"wsClientError\")) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n    server.emit(\"wsClientError\", err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\nconst websocketServer$1 = /* @__PURE__ */getDefaultExportFromCjs(websocketServer);\nexport { receiver$1 as Receiver, sender$1 as Sender, WebSocket$2 as WebSocket, websocketServer$1 as WebSocketServer, stream$1 as createWebSocketStream, WebSocket$2 as default };","map":{"version":3,"names":["require$$0","require$$0$1","require$$0$2","require$$3","require$$4","require$$5","require$$0$3","require$$1$1","require$$2","require$$7","getDefaultExportFromCjs","x","__esModule","Object","prototype","hasOwnProperty","call","getAugmentedNamespace","n","f","default","a","a2","args","push","apply","arguments","Ctor","Function","bind","defineProperty","value","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","Duplex","emitClose$1","stream2","emit","duplexOnEnd","destroyed","_writableState","finished","destroy","duplexOnError","err","removeListener","listenerCount","createWebSocketStream","ws","options","terminateOnDestroy","duplex","autoDestroy","emitClose","objectMode","writableObjectMode","on","message","msg","isBinary","data","_readableState","toString","pause","once","error2","close","_destroy","callback","readyState","CLOSED","process","nextTick","called","err2","terminate","_final","CONNECTING","open","_socket","endEmitted","finish","_read","isPaused","resume","_write","chunk","encoding","send","stream","stream$1","bufferUtil$1","exports","constants","BINARY_TYPES","EMPTY_BUFFER","Buffer","alloc","GUID","kForOnEventAttribute","Symbol","kListener","kStatusCode","kWebSocket","NOOP","unmask$1","mask","EMPTY_BUFFER$3","FastBuffer$2","species","concat$1","list","totalLength","length","target","allocUnsafe","offset","i","buf","set","buffer","byteOffset","_mask","source","mask2","output","_unmask","toArrayBuffer$1","byteLength","slice","toBuffer$2","readOnly","isBuffer","ArrayBuffer","isView","from","concat","toArrayBuffer","toBuffer","unmask","env","WS_NO_BUFFER_UTIL","bufferUtil2","require","e","bufferUtilExports","kDone","kRun","Limiter$1","Limiter","constructor","concurrency","pending","Infinity","jobs","add","job","shift","limiter","zlib","bufferUtil","Limiter2","kStatusCode$2","FastBuffer$1","TRAILER","kPerMessageDeflate","kTotalLength","kCallback","kBuffers","kError$1","zlibLimiter","PerMessageDeflate$4","PerMessageDeflate","isServer","maxPayload","_maxPayload","_options","_threshold","threshold","_isServer","_deflate","_inflate","params","concurrencyLimit","extensionName","offer","serverNoContextTakeover","server_no_context_takeover","clientNoContextTakeover","client_no_context_takeover","serverMaxWindowBits","server_max_window_bits","clientMaxWindowBits","client_max_window_bits","accept","configurations","normalizeParams","acceptAsServer","acceptAsClient","cleanup","Error","offers","opts","accepted","find","response","key","num","Number","isInteger","TypeError","decompress","fin","done","_decompress","result","compress","_compress","endpoint","windowBits","Z_DEFAULT_WINDOWBITS","createInflateRaw","zlibInflateOptions","inflateOnError","inflateOnData","write","flush","data2","reset","createDeflateRaw","zlibDeflateOptions","deflateOnData","Z_SYNC_FLUSH","permessageDeflate","RangeError","code","validation","__viteOptionalPeerDep_utf8Validate_ws","__viteOptionalPeerDep_utf8Validate_ws$1","freeze","__proto__","toStringTag","require$$1","isValidUTF8_1","isUtf8","tokenChars$2","isValidStatusCode$2","_isValidUTF8","len","isValidStatusCode","isValidUTF8","tokenChars","WS_NO_UTF_8_VALIDATE","isValidUTF82","validationExports","Writable","PerMessageDeflate$3","BINARY_TYPES$1","EMPTY_BUFFER$2","kStatusCode$1","kWebSocket$2","isValidStatusCode$1","FastBuffer","GET_INFO","GET_PAYLOAD_LENGTH_16","GET_PAYLOAD_LENGTH_64","GET_MASK","GET_DATA","INFLATING","Receiver$1","Receiver","_binaryType","binaryType","_extensions","extensions","_skipUTF8Validation","skipUTF8Validation","_bufferedBytes","_buffers","_compressed","_payloadLength","_fragmented","_masked","_fin","_opcode","_totalPayloadLength","_messageLength","_fragments","_state","_loop","cb","startLoop","consume","dst","Uint8Array","getInfo","getPayloadLength16","getPayloadLength64","getMask","getData","error","compressed","haveLength","readUInt16BE","readUInt32BE","Math","pow","controlMessage","dataMessage","perMessageDeflate","er","messageLength","fragments","end","receiver","ErrorCtor","prefix","statusCode","errorCode","captureStackTrace","receiver$1","randomFillSync","PerMessageDeflate$2","EMPTY_BUFFER$1","applyMask","toBuffer$1","kByteLength","maskBuffer","Sender$1","Sender","socket","generateMask","_generateMask","_maskBuffer","_firstFragment","_deflating","_queue","frame","merge","skipMasking","dataLength","payloadLength","opcode","rsv1","writeUInt16BE","writeUIntBE","enqueue","dispatch","sendFrame","ping","pong","binary","_","dequeue","Reflect","cork","uncork","sender","sender$1","kForOnEventAttribute$1","kListener$1","kCode","kData","kError","kMessage","kReason","kTarget","kType","kWasClean","Event","type","CloseEvent","reason","wasClean","ErrorEvent","MessageEvent","EventTarget","addEventListener","handler","listener","listeners","wrapper","onMessage","event","callListener","onClose","_closeFrameReceived","_closeFrameSent","onError","onOpen","removeEventListener","eventTarget","thisArg","handleEvent","tokenChars$1","dest","name","elem","parse$2","header","create","mustUnescape","isEscaping","inQuotes","paramName","start","charCodeAt","SyntaxError","replace","token","format$1","map","extension2","Array","isArray","values","v","join","extension$1","format","parse","EventEmitter$1","https","http$1","net","tls","randomBytes","createHash","createHash$1","URL","PerMessageDeflate$1","Receiver2","Sender2","GUID$1","kWebSocket$1","parse$1","closeTimeout","kAborted","protocolVersions","readyStates","subprotocolRegex","WebSocket$1","WebSocket","address","protocols","_closeCode","_closeMessage","_closeTimer","_paused","_protocol","_readyState","_receiver","_sender","_bufferedAmount","_redirects","initAsClient","includes","bufferedAmount","onclose","onerror","onopen","onmessage","protocol","url","_url","setSocket","head","receiver2","receiverOnConclude","receiverOnDrain","receiverOnError","receiverOnMessage","receiverOnPing","receiverOnPong","setTimeout","setNoDelay","unshift","socketOnClose","socketOnData","socketOnEnd","socketOnError$1","OPEN","removeAllListeners","abortHandshake$1","_req","CLOSING","errorEmitted","sendAfterClose","needDrain","indexOf","property","method","websocket","websocket2","protocolVersion","followRedirects","maxRedirects","createConnection","socketPath","hostname","timeout","host","path","port","parsedUrl","href","isSecure","isIpcUrl","invalidUrlMessage","pathname","hash","emitErrorAndClose","defaultPort","request","protocolSet","Set","tlsConnect","netConnect","startsWith","headers","Connection","Upgrade","search","handshakeTimeout","test","has","origin","Origin","username","password","auth","parts","split","req","_originalIpc","_originalSecure","_originalHostOrSocketPath","key2","entries","toLowerCase","isSameHost","authorization","cookie","res","location","abort","addr","upgrade","digest","update","serverProt","protError","size","secWebSocketExtensions","extensionNames","finishRequest","connect","servername","isIP","setHeader","receiverOnFinish","read","clearTimeout","WebSocket$2","protocol2","subprotocol$1","EventEmitter","http","extension","PerMessageDeflate2","subprotocol","WebSocket2","keyRegex","RUNNING","WebSocketServer","handleProtocols","clientTracking","verifyClient","noServer","backlog","server","_server","createServer","body","STATUS_CODES","writeHead","listen","emitConnection","_removeListeners","addListeners","listening","handleUpgrade","clients","_shouldEmitClose","shouldHandle","index","socketOnError","version","abortHandshakeOrEmitwsClientError","abortHandshake","secWebSocketProtocol","info","secure","authorized","encrypted","verified","completeUpgrade","readable","writable","next","delete","websocketServer","removeListeners","h","websocketServer$1"],"sources":["C:/Users/juju7/starry-eyed/node_modules/@gradio/client/dist/wrapper-6f348d45.js"],"sourcesContent":["import require$$0 from \"stream\";\r\nimport require$$0$1 from \"zlib\";\r\nimport require$$0$2 from \"buffer\";\r\nimport require$$3 from \"net\";\r\nimport require$$4 from \"tls\";\r\nimport require$$5 from \"crypto\";\r\nimport require$$0$3 from \"events\";\r\nimport require$$1$1 from \"https\";\r\nimport require$$2 from \"http\";\r\nimport require$$7 from \"url\";\r\nfunction getDefaultExportFromCjs(x) {\r\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\r\n}\r\nfunction getAugmentedNamespace(n) {\r\n  if (n.__esModule)\r\n    return n;\r\n  var f = n.default;\r\n  if (typeof f == \"function\") {\r\n    var a = function a2() {\r\n      if (this instanceof a2) {\r\n        var args = [null];\r\n        args.push.apply(args, arguments);\r\n        var Ctor = Function.bind.apply(f, args);\r\n        return new Ctor();\r\n      }\r\n      return f.apply(this, arguments);\r\n    };\r\n    a.prototype = f.prototype;\r\n  } else\r\n    a = {};\r\n  Object.defineProperty(a, \"__esModule\", { value: true });\r\n  Object.keys(n).forEach(function(k) {\r\n    var d = Object.getOwnPropertyDescriptor(n, k);\r\n    Object.defineProperty(a, k, d.get ? d : {\r\n      enumerable: true,\r\n      get: function() {\r\n        return n[k];\r\n      }\r\n    });\r\n  });\r\n  return a;\r\n}\r\nconst { Duplex } = require$$0;\r\nfunction emitClose$1(stream2) {\r\n  stream2.emit(\"close\");\r\n}\r\nfunction duplexOnEnd() {\r\n  if (!this.destroyed && this._writableState.finished) {\r\n    this.destroy();\r\n  }\r\n}\r\nfunction duplexOnError(err) {\r\n  this.removeListener(\"error\", duplexOnError);\r\n  this.destroy();\r\n  if (this.listenerCount(\"error\") === 0) {\r\n    this.emit(\"error\", err);\r\n  }\r\n}\r\nfunction createWebSocketStream(ws, options) {\r\n  let terminateOnDestroy = true;\r\n  const duplex = new Duplex({\r\n    ...options,\r\n    autoDestroy: false,\r\n    emitClose: false,\r\n    objectMode: false,\r\n    writableObjectMode: false\r\n  });\r\n  ws.on(\"message\", function message(msg, isBinary) {\r\n    const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\r\n    if (!duplex.push(data))\r\n      ws.pause();\r\n  });\r\n  ws.once(\"error\", function error2(err) {\r\n    if (duplex.destroyed)\r\n      return;\r\n    terminateOnDestroy = false;\r\n    duplex.destroy(err);\r\n  });\r\n  ws.once(\"close\", function close() {\r\n    if (duplex.destroyed)\r\n      return;\r\n    duplex.push(null);\r\n  });\r\n  duplex._destroy = function(err, callback) {\r\n    if (ws.readyState === ws.CLOSED) {\r\n      callback(err);\r\n      process.nextTick(emitClose$1, duplex);\r\n      return;\r\n    }\r\n    let called = false;\r\n    ws.once(\"error\", function error2(err2) {\r\n      called = true;\r\n      callback(err2);\r\n    });\r\n    ws.once(\"close\", function close() {\r\n      if (!called)\r\n        callback(err);\r\n      process.nextTick(emitClose$1, duplex);\r\n    });\r\n    if (terminateOnDestroy)\r\n      ws.terminate();\r\n  };\r\n  duplex._final = function(callback) {\r\n    if (ws.readyState === ws.CONNECTING) {\r\n      ws.once(\"open\", function open() {\r\n        duplex._final(callback);\r\n      });\r\n      return;\r\n    }\r\n    if (ws._socket === null)\r\n      return;\r\n    if (ws._socket._writableState.finished) {\r\n      callback();\r\n      if (duplex._readableState.endEmitted)\r\n        duplex.destroy();\r\n    } else {\r\n      ws._socket.once(\"finish\", function finish() {\r\n        callback();\r\n      });\r\n      ws.close();\r\n    }\r\n  };\r\n  duplex._read = function() {\r\n    if (ws.isPaused)\r\n      ws.resume();\r\n  };\r\n  duplex._write = function(chunk, encoding, callback) {\r\n    if (ws.readyState === ws.CONNECTING) {\r\n      ws.once(\"open\", function open() {\r\n        duplex._write(chunk, encoding, callback);\r\n      });\r\n      return;\r\n    }\r\n    ws.send(chunk, callback);\r\n  };\r\n  duplex.on(\"end\", duplexOnEnd);\r\n  duplex.on(\"error\", duplexOnError);\r\n  return duplex;\r\n}\r\nvar stream = createWebSocketStream;\r\nconst stream$1 = /* @__PURE__ */ getDefaultExportFromCjs(stream);\r\nvar bufferUtil$1 = { exports: {} };\r\nvar constants = {\r\n  BINARY_TYPES: [\"nodebuffer\", \"arraybuffer\", \"fragments\"],\r\n  EMPTY_BUFFER: Buffer.alloc(0),\r\n  GUID: \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\",\r\n  kForOnEventAttribute: Symbol(\"kIsForOnEventAttribute\"),\r\n  kListener: Symbol(\"kListener\"),\r\n  kStatusCode: Symbol(\"status-code\"),\r\n  kWebSocket: Symbol(\"websocket\"),\r\n  NOOP: () => {\r\n  }\r\n};\r\nvar unmask$1;\r\nvar mask;\r\nconst { EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants;\r\nconst FastBuffer$2 = Buffer[Symbol.species];\r\nfunction concat$1(list, totalLength) {\r\n  if (list.length === 0)\r\n    return EMPTY_BUFFER$3;\r\n  if (list.length === 1)\r\n    return list[0];\r\n  const target = Buffer.allocUnsafe(totalLength);\r\n  let offset = 0;\r\n  for (let i = 0; i < list.length; i++) {\r\n    const buf = list[i];\r\n    target.set(buf, offset);\r\n    offset += buf.length;\r\n  }\r\n  if (offset < totalLength) {\r\n    return new FastBuffer$2(target.buffer, target.byteOffset, offset);\r\n  }\r\n  return target;\r\n}\r\nfunction _mask(source, mask2, output, offset, length) {\r\n  for (let i = 0; i < length; i++) {\r\n    output[offset + i] = source[i] ^ mask2[i & 3];\r\n  }\r\n}\r\nfunction _unmask(buffer, mask2) {\r\n  for (let i = 0; i < buffer.length; i++) {\r\n    buffer[i] ^= mask2[i & 3];\r\n  }\r\n}\r\nfunction toArrayBuffer$1(buf) {\r\n  if (buf.length === buf.buffer.byteLength) {\r\n    return buf.buffer;\r\n  }\r\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\r\n}\r\nfunction toBuffer$2(data) {\r\n  toBuffer$2.readOnly = true;\r\n  if (Buffer.isBuffer(data))\r\n    return data;\r\n  let buf;\r\n  if (data instanceof ArrayBuffer) {\r\n    buf = new FastBuffer$2(data);\r\n  } else if (ArrayBuffer.isView(data)) {\r\n    buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);\r\n  } else {\r\n    buf = Buffer.from(data);\r\n    toBuffer$2.readOnly = false;\r\n  }\r\n  return buf;\r\n}\r\nbufferUtil$1.exports = {\r\n  concat: concat$1,\r\n  mask: _mask,\r\n  toArrayBuffer: toArrayBuffer$1,\r\n  toBuffer: toBuffer$2,\r\n  unmask: _unmask\r\n};\r\nif (!process.env.WS_NO_BUFFER_UTIL) {\r\n  try {\r\n    const bufferUtil2 = require(\"bufferutil\");\r\n    mask = bufferUtil$1.exports.mask = function(source, mask2, output, offset, length) {\r\n      if (length < 48)\r\n        _mask(source, mask2, output, offset, length);\r\n      else\r\n        bufferUtil2.mask(source, mask2, output, offset, length);\r\n    };\r\n    unmask$1 = bufferUtil$1.exports.unmask = function(buffer, mask2) {\r\n      if (buffer.length < 32)\r\n        _unmask(buffer, mask2);\r\n      else\r\n        bufferUtil2.unmask(buffer, mask2);\r\n    };\r\n  } catch (e) {\r\n  }\r\n}\r\nvar bufferUtilExports = bufferUtil$1.exports;\r\nconst kDone = Symbol(\"kDone\");\r\nconst kRun = Symbol(\"kRun\");\r\nlet Limiter$1 = class Limiter {\r\n  /**\r\n   * Creates a new `Limiter`.\r\n   *\r\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\r\n   *     to run concurrently\r\n   */\r\n  constructor(concurrency) {\r\n    this[kDone] = () => {\r\n      this.pending--;\r\n      this[kRun]();\r\n    };\r\n    this.concurrency = concurrency || Infinity;\r\n    this.jobs = [];\r\n    this.pending = 0;\r\n  }\r\n  /**\r\n   * Adds a job to the queue.\r\n   *\r\n   * @param {Function} job The job to run\r\n   * @public\r\n   */\r\n  add(job) {\r\n    this.jobs.push(job);\r\n    this[kRun]();\r\n  }\r\n  /**\r\n   * Removes a job from the queue and runs it if possible.\r\n   *\r\n   * @private\r\n   */\r\n  [kRun]() {\r\n    if (this.pending === this.concurrency)\r\n      return;\r\n    if (this.jobs.length) {\r\n      const job = this.jobs.shift();\r\n      this.pending++;\r\n      job(this[kDone]);\r\n    }\r\n  }\r\n};\r\nvar limiter = Limiter$1;\r\nconst zlib = require$$0$1;\r\nconst bufferUtil = bufferUtilExports;\r\nconst Limiter2 = limiter;\r\nconst { kStatusCode: kStatusCode$2 } = constants;\r\nconst FastBuffer$1 = Buffer[Symbol.species];\r\nconst TRAILER = Buffer.from([0, 0, 255, 255]);\r\nconst kPerMessageDeflate = Symbol(\"permessage-deflate\");\r\nconst kTotalLength = Symbol(\"total-length\");\r\nconst kCallback = Symbol(\"callback\");\r\nconst kBuffers = Symbol(\"buffers\");\r\nconst kError$1 = Symbol(\"error\");\r\nlet zlibLimiter;\r\nlet PerMessageDeflate$4 = class PerMessageDeflate {\r\n  /**\r\n   * Creates a PerMessageDeflate instance.\r\n   *\r\n   * @param {Object} [options] Configuration options\r\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\r\n   *     for, or request, a custom client window size\r\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\r\n   *     acknowledge disabling of client context takeover\r\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\r\n   *     calls to zlib\r\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\r\n   *     use of a custom server window size\r\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\r\n   *     disabling of server context takeover\r\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\r\n   *     messages should not be compressed if context takeover is disabled\r\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\r\n   *     deflate\r\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\r\n   *     inflate\r\n   * @param {Boolean} [isServer=false] Create the instance in either server or\r\n   *     client mode\r\n   * @param {Number} [maxPayload=0] The maximum allowed message length\r\n   */\r\n  constructor(options, isServer, maxPayload) {\r\n    this._maxPayload = maxPayload | 0;\r\n    this._options = options || {};\r\n    this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;\r\n    this._isServer = !!isServer;\r\n    this._deflate = null;\r\n    this._inflate = null;\r\n    this.params = null;\r\n    if (!zlibLimiter) {\r\n      const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;\r\n      zlibLimiter = new Limiter2(concurrency);\r\n    }\r\n  }\r\n  /**\r\n   * @type {String}\r\n   */\r\n  static get extensionName() {\r\n    return \"permessage-deflate\";\r\n  }\r\n  /**\r\n   * Create an extension negotiation offer.\r\n   *\r\n   * @return {Object} Extension parameters\r\n   * @public\r\n   */\r\n  offer() {\r\n    const params = {};\r\n    if (this._options.serverNoContextTakeover) {\r\n      params.server_no_context_takeover = true;\r\n    }\r\n    if (this._options.clientNoContextTakeover) {\r\n      params.client_no_context_takeover = true;\r\n    }\r\n    if (this._options.serverMaxWindowBits) {\r\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\r\n    }\r\n    if (this._options.clientMaxWindowBits) {\r\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\r\n    } else if (this._options.clientMaxWindowBits == null) {\r\n      params.client_max_window_bits = true;\r\n    }\r\n    return params;\r\n  }\r\n  /**\r\n   * Accept an extension negotiation offer/response.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Object} Accepted configuration\r\n   * @public\r\n   */\r\n  accept(configurations) {\r\n    configurations = this.normalizeParams(configurations);\r\n    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\r\n    return this.params;\r\n  }\r\n  /**\r\n   * Releases all resources used by the extension.\r\n   *\r\n   * @public\r\n   */\r\n  cleanup() {\r\n    if (this._inflate) {\r\n      this._inflate.close();\r\n      this._inflate = null;\r\n    }\r\n    if (this._deflate) {\r\n      const callback = this._deflate[kCallback];\r\n      this._deflate.close();\r\n      this._deflate = null;\r\n      if (callback) {\r\n        callback(\r\n          new Error(\r\n            \"The deflate stream was closed while data was being processed\"\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   *  Accept an extension negotiation offer.\r\n   *\r\n   * @param {Array} offers The extension negotiation offers\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\r\n  acceptAsServer(offers) {\r\n    const opts = this._options;\r\n    const accepted = offers.find((params) => {\r\n      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === \"number\" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n    if (!accepted) {\r\n      throw new Error(\"None of the extension offers can be accepted\");\r\n    }\r\n    if (opts.serverNoContextTakeover) {\r\n      accepted.server_no_context_takeover = true;\r\n    }\r\n    if (opts.clientNoContextTakeover) {\r\n      accepted.client_no_context_takeover = true;\r\n    }\r\n    if (typeof opts.serverMaxWindowBits === \"number\") {\r\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\r\n    }\r\n    if (typeof opts.clientMaxWindowBits === \"number\") {\r\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\r\n    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\r\n      delete accepted.client_max_window_bits;\r\n    }\r\n    return accepted;\r\n  }\r\n  /**\r\n   * Accept the extension negotiation response.\r\n   *\r\n   * @param {Array} response The extension negotiation response\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\r\n  acceptAsClient(response) {\r\n    const params = response[0];\r\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\r\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\r\n    }\r\n    if (!params.client_max_window_bits) {\r\n      if (typeof this._options.clientMaxWindowBits === \"number\") {\r\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\r\n      }\r\n    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === \"number\" && params.client_max_window_bits > this._options.clientMaxWindowBits) {\r\n      throw new Error(\r\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\r\n      );\r\n    }\r\n    return params;\r\n  }\r\n  /**\r\n   * Normalize parameters.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Array} The offers/response with normalized parameters\r\n   * @private\r\n   */\r\n  normalizeParams(configurations) {\r\n    configurations.forEach((params) => {\r\n      Object.keys(params).forEach((key) => {\r\n        let value = params[key];\r\n        if (value.length > 1) {\r\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\r\n        }\r\n        value = value[0];\r\n        if (key === \"client_max_window_bits\") {\r\n          if (value !== true) {\r\n            const num = +value;\r\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\r\n              throw new TypeError(\r\n                `Invalid value for parameter \"${key}\": ${value}`\r\n              );\r\n            }\r\n            value = num;\r\n          } else if (!this._isServer) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n        } else if (key === \"server_max_window_bits\") {\r\n          const num = +value;\r\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n          value = num;\r\n        } else if (key === \"client_no_context_takeover\" || key === \"server_no_context_takeover\") {\r\n          if (value !== true) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n        } else {\r\n          throw new Error(`Unknown parameter \"${key}\"`);\r\n        }\r\n        params[key] = value;\r\n      });\r\n    });\r\n    return configurations;\r\n  }\r\n  /**\r\n   * Decompress data. Concurrency limited.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\r\n  decompress(data, fin, callback) {\r\n    zlibLimiter.add((done) => {\r\n      this._decompress(data, fin, (err, result) => {\r\n        done();\r\n        callback(err, result);\r\n      });\r\n    });\r\n  }\r\n  /**\r\n   * Compress data. Concurrency limited.\r\n   *\r\n   * @param {(Buffer|String)} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\r\n  compress(data, fin, callback) {\r\n    zlibLimiter.add((done) => {\r\n      this._compress(data, fin, (err, result) => {\r\n        done();\r\n        callback(err, result);\r\n      });\r\n    });\r\n  }\r\n  /**\r\n   * Decompress data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\r\n  _decompress(data, fin, callback) {\r\n    const endpoint = this._isServer ? \"client\" : \"server\";\r\n    if (!this._inflate) {\r\n      const key = `${endpoint}_max_window_bits`;\r\n      const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\r\n      this._inflate = zlib.createInflateRaw({\r\n        ...this._options.zlibInflateOptions,\r\n        windowBits\r\n      });\r\n      this._inflate[kPerMessageDeflate] = this;\r\n      this._inflate[kTotalLength] = 0;\r\n      this._inflate[kBuffers] = [];\r\n      this._inflate.on(\"error\", inflateOnError);\r\n      this._inflate.on(\"data\", inflateOnData);\r\n    }\r\n    this._inflate[kCallback] = callback;\r\n    this._inflate.write(data);\r\n    if (fin)\r\n      this._inflate.write(TRAILER);\r\n    this._inflate.flush(() => {\r\n      const err = this._inflate[kError$1];\r\n      if (err) {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n        callback(err);\r\n        return;\r\n      }\r\n      const data2 = bufferUtil.concat(\r\n        this._inflate[kBuffers],\r\n        this._inflate[kTotalLength]\r\n      );\r\n      if (this._inflate._readableState.endEmitted) {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n      } else {\r\n        this._inflate[kTotalLength] = 0;\r\n        this._inflate[kBuffers] = [];\r\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\r\n          this._inflate.reset();\r\n        }\r\n      }\r\n      callback(null, data2);\r\n    });\r\n  }\r\n  /**\r\n   * Compress data.\r\n   *\r\n   * @param {(Buffer|String)} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\r\n  _compress(data, fin, callback) {\r\n    const endpoint = this._isServer ? \"server\" : \"client\";\r\n    if (!this._deflate) {\r\n      const key = `${endpoint}_max_window_bits`;\r\n      const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\r\n      this._deflate = zlib.createDeflateRaw({\r\n        ...this._options.zlibDeflateOptions,\r\n        windowBits\r\n      });\r\n      this._deflate[kTotalLength] = 0;\r\n      this._deflate[kBuffers] = [];\r\n      this._deflate.on(\"data\", deflateOnData);\r\n    }\r\n    this._deflate[kCallback] = callback;\r\n    this._deflate.write(data);\r\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\r\n      if (!this._deflate) {\r\n        return;\r\n      }\r\n      let data2 = bufferUtil.concat(\r\n        this._deflate[kBuffers],\r\n        this._deflate[kTotalLength]\r\n      );\r\n      if (fin) {\r\n        data2 = new FastBuffer$1(data2.buffer, data2.byteOffset, data2.length - 4);\r\n      }\r\n      this._deflate[kCallback] = null;\r\n      this._deflate[kTotalLength] = 0;\r\n      this._deflate[kBuffers] = [];\r\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\r\n        this._deflate.reset();\r\n      }\r\n      callback(null, data2);\r\n    });\r\n  }\r\n};\r\nvar permessageDeflate = PerMessageDeflate$4;\r\nfunction deflateOnData(chunk) {\r\n  this[kBuffers].push(chunk);\r\n  this[kTotalLength] += chunk.length;\r\n}\r\nfunction inflateOnData(chunk) {\r\n  this[kTotalLength] += chunk.length;\r\n  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\r\n    this[kBuffers].push(chunk);\r\n    return;\r\n  }\r\n  this[kError$1] = new RangeError(\"Max payload size exceeded\");\r\n  this[kError$1].code = \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\";\r\n  this[kError$1][kStatusCode$2] = 1009;\r\n  this.removeListener(\"data\", inflateOnData);\r\n  this.reset();\r\n}\r\nfunction inflateOnError(err) {\r\n  this[kPerMessageDeflate]._inflate = null;\r\n  err[kStatusCode$2] = 1007;\r\n  this[kCallback](err);\r\n}\r\nvar validation = { exports: {} };\r\nconst __viteOptionalPeerDep_utf8Validate_ws = {};\r\nconst __viteOptionalPeerDep_utf8Validate_ws$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\r\n  __proto__: null,\r\n  default: __viteOptionalPeerDep_utf8Validate_ws\r\n}, Symbol.toStringTag, { value: \"Module\" }));\r\nconst require$$1 = /* @__PURE__ */ getAugmentedNamespace(__viteOptionalPeerDep_utf8Validate_ws$1);\r\nvar isValidUTF8_1;\r\nconst { isUtf8 } = require$$0$2;\r\nconst tokenChars$2 = [\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  // 0 - 15\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  // 16 - 31\r\n  0,\r\n  1,\r\n  0,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  0,\r\n  0,\r\n  1,\r\n  1,\r\n  0,\r\n  1,\r\n  1,\r\n  0,\r\n  // 32 - 47\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  0,\r\n  // 48 - 63\r\n  0,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  // 64 - 79\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  0,\r\n  0,\r\n  0,\r\n  1,\r\n  1,\r\n  // 80 - 95\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  // 96 - 111\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  1,\r\n  0,\r\n  1,\r\n  0,\r\n  1,\r\n  0\r\n  // 112 - 127\r\n];\r\nfunction isValidStatusCode$2(code) {\r\n  return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;\r\n}\r\nfunction _isValidUTF8(buf) {\r\n  const len = buf.length;\r\n  let i = 0;\r\n  while (i < len) {\r\n    if ((buf[i] & 128) === 0) {\r\n      i++;\r\n    } else if ((buf[i] & 224) === 192) {\r\n      if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {\r\n        return false;\r\n      }\r\n      i += 2;\r\n    } else if ((buf[i] & 240) === 224) {\r\n      if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong\r\n      buf[i] === 237 && (buf[i + 1] & 224) === 160) {\r\n        return false;\r\n      }\r\n      i += 3;\r\n    } else if ((buf[i] & 248) === 240) {\r\n      if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong\r\n      buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {\r\n        return false;\r\n      }\r\n      i += 4;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\nvalidation.exports = {\r\n  isValidStatusCode: isValidStatusCode$2,\r\n  isValidUTF8: _isValidUTF8,\r\n  tokenChars: tokenChars$2\r\n};\r\nif (isUtf8) {\r\n  isValidUTF8_1 = validation.exports.isValidUTF8 = function(buf) {\r\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\r\n  };\r\n} else if (!process.env.WS_NO_UTF_8_VALIDATE) {\r\n  try {\r\n    const isValidUTF82 = require$$1;\r\n    isValidUTF8_1 = validation.exports.isValidUTF8 = function(buf) {\r\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF82(buf);\r\n    };\r\n  } catch (e) {\r\n  }\r\n}\r\nvar validationExports = validation.exports;\r\nconst { Writable } = require$$0;\r\nconst PerMessageDeflate$3 = permessageDeflate;\r\nconst {\r\n  BINARY_TYPES: BINARY_TYPES$1,\r\n  EMPTY_BUFFER: EMPTY_BUFFER$2,\r\n  kStatusCode: kStatusCode$1,\r\n  kWebSocket: kWebSocket$2\r\n} = constants;\r\nconst { concat, toArrayBuffer, unmask } = bufferUtilExports;\r\nconst { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validationExports;\r\nconst FastBuffer = Buffer[Symbol.species];\r\nconst GET_INFO = 0;\r\nconst GET_PAYLOAD_LENGTH_16 = 1;\r\nconst GET_PAYLOAD_LENGTH_64 = 2;\r\nconst GET_MASK = 3;\r\nconst GET_DATA = 4;\r\nconst INFLATING = 5;\r\nlet Receiver$1 = class Receiver extends Writable {\r\n  /**\r\n   * Creates a Receiver instance.\r\n   *\r\n   * @param {Object} [options] Options object\r\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\r\n   * @param {Object} [options.extensions] An object containing the negotiated\r\n   *     extensions\r\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\r\n   *     client or server mode\r\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   */\r\n  constructor(options = {}) {\r\n    super();\r\n    this._binaryType = options.binaryType || BINARY_TYPES$1[0];\r\n    this._extensions = options.extensions || {};\r\n    this._isServer = !!options.isServer;\r\n    this._maxPayload = options.maxPayload | 0;\r\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\r\n    this[kWebSocket$2] = void 0;\r\n    this._bufferedBytes = 0;\r\n    this._buffers = [];\r\n    this._compressed = false;\r\n    this._payloadLength = 0;\r\n    this._mask = void 0;\r\n    this._fragmented = 0;\r\n    this._masked = false;\r\n    this._fin = false;\r\n    this._opcode = 0;\r\n    this._totalPayloadLength = 0;\r\n    this._messageLength = 0;\r\n    this._fragments = [];\r\n    this._state = GET_INFO;\r\n    this._loop = false;\r\n  }\r\n  /**\r\n   * Implements `Writable.prototype._write()`.\r\n   *\r\n   * @param {Buffer} chunk The chunk of data to write\r\n   * @param {String} encoding The character encoding of `chunk`\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  _write(chunk, encoding, cb) {\r\n    if (this._opcode === 8 && this._state == GET_INFO)\r\n      return cb();\r\n    this._bufferedBytes += chunk.length;\r\n    this._buffers.push(chunk);\r\n    this.startLoop(cb);\r\n  }\r\n  /**\r\n   * Consumes `n` bytes from the buffered data.\r\n   *\r\n   * @param {Number} n The number of bytes to consume\r\n   * @return {Buffer} The consumed bytes\r\n   * @private\r\n   */\r\n  consume(n) {\r\n    this._bufferedBytes -= n;\r\n    if (n === this._buffers[0].length)\r\n      return this._buffers.shift();\r\n    if (n < this._buffers[0].length) {\r\n      const buf = this._buffers[0];\r\n      this._buffers[0] = new FastBuffer(\r\n        buf.buffer,\r\n        buf.byteOffset + n,\r\n        buf.length - n\r\n      );\r\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\r\n    }\r\n    const dst = Buffer.allocUnsafe(n);\r\n    do {\r\n      const buf = this._buffers[0];\r\n      const offset = dst.length - n;\r\n      if (n >= buf.length) {\r\n        dst.set(this._buffers.shift(), offset);\r\n      } else {\r\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\r\n        this._buffers[0] = new FastBuffer(\r\n          buf.buffer,\r\n          buf.byteOffset + n,\r\n          buf.length - n\r\n        );\r\n      }\r\n      n -= buf.length;\r\n    } while (n > 0);\r\n    return dst;\r\n  }\r\n  /**\r\n   * Starts the parsing loop.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  startLoop(cb) {\r\n    let err;\r\n    this._loop = true;\r\n    do {\r\n      switch (this._state) {\r\n        case GET_INFO:\r\n          err = this.getInfo();\r\n          break;\r\n        case GET_PAYLOAD_LENGTH_16:\r\n          err = this.getPayloadLength16();\r\n          break;\r\n        case GET_PAYLOAD_LENGTH_64:\r\n          err = this.getPayloadLength64();\r\n          break;\r\n        case GET_MASK:\r\n          this.getMask();\r\n          break;\r\n        case GET_DATA:\r\n          err = this.getData(cb);\r\n          break;\r\n        default:\r\n          this._loop = false;\r\n          return;\r\n      }\r\n    } while (this._loop);\r\n    cb(err);\r\n  }\r\n  /**\r\n   * Reads the first two bytes of a frame.\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  getInfo() {\r\n    if (this._bufferedBytes < 2) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n    const buf = this.consume(2);\r\n    if ((buf[0] & 48) !== 0) {\r\n      this._loop = false;\r\n      return error(\r\n        RangeError,\r\n        \"RSV2 and RSV3 must be clear\",\r\n        true,\r\n        1002,\r\n        \"WS_ERR_UNEXPECTED_RSV_2_3\"\r\n      );\r\n    }\r\n    const compressed = (buf[0] & 64) === 64;\r\n    if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {\r\n      this._loop = false;\r\n      return error(\r\n        RangeError,\r\n        \"RSV1 must be clear\",\r\n        true,\r\n        1002,\r\n        \"WS_ERR_UNEXPECTED_RSV_1\"\r\n      );\r\n    }\r\n    this._fin = (buf[0] & 128) === 128;\r\n    this._opcode = buf[0] & 15;\r\n    this._payloadLength = buf[1] & 127;\r\n    if (this._opcode === 0) {\r\n      if (compressed) {\r\n        this._loop = false;\r\n        return error(\r\n          RangeError,\r\n          \"RSV1 must be clear\",\r\n          true,\r\n          1002,\r\n          \"WS_ERR_UNEXPECTED_RSV_1\"\r\n        );\r\n      }\r\n      if (!this._fragmented) {\r\n        this._loop = false;\r\n        return error(\r\n          RangeError,\r\n          \"invalid opcode 0\",\r\n          true,\r\n          1002,\r\n          \"WS_ERR_INVALID_OPCODE\"\r\n        );\r\n      }\r\n      this._opcode = this._fragmented;\r\n    } else if (this._opcode === 1 || this._opcode === 2) {\r\n      if (this._fragmented) {\r\n        this._loop = false;\r\n        return error(\r\n          RangeError,\r\n          `invalid opcode ${this._opcode}`,\r\n          true,\r\n          1002,\r\n          \"WS_ERR_INVALID_OPCODE\"\r\n        );\r\n      }\r\n      this._compressed = compressed;\r\n    } else if (this._opcode > 7 && this._opcode < 11) {\r\n      if (!this._fin) {\r\n        this._loop = false;\r\n        return error(\r\n          RangeError,\r\n          \"FIN must be set\",\r\n          true,\r\n          1002,\r\n          \"WS_ERR_EXPECTED_FIN\"\r\n        );\r\n      }\r\n      if (compressed) {\r\n        this._loop = false;\r\n        return error(\r\n          RangeError,\r\n          \"RSV1 must be clear\",\r\n          true,\r\n          1002,\r\n          \"WS_ERR_UNEXPECTED_RSV_1\"\r\n        );\r\n      }\r\n      if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {\r\n        this._loop = false;\r\n        return error(\r\n          RangeError,\r\n          `invalid payload length ${this._payloadLength}`,\r\n          true,\r\n          1002,\r\n          \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\"\r\n        );\r\n      }\r\n    } else {\r\n      this._loop = false;\r\n      return error(\r\n        RangeError,\r\n        `invalid opcode ${this._opcode}`,\r\n        true,\r\n        1002,\r\n        \"WS_ERR_INVALID_OPCODE\"\r\n      );\r\n    }\r\n    if (!this._fin && !this._fragmented)\r\n      this._fragmented = this._opcode;\r\n    this._masked = (buf[1] & 128) === 128;\r\n    if (this._isServer) {\r\n      if (!this._masked) {\r\n        this._loop = false;\r\n        return error(\r\n          RangeError,\r\n          \"MASK must be set\",\r\n          true,\r\n          1002,\r\n          \"WS_ERR_EXPECTED_MASK\"\r\n        );\r\n      }\r\n    } else if (this._masked) {\r\n      this._loop = false;\r\n      return error(\r\n        RangeError,\r\n        \"MASK must be clear\",\r\n        true,\r\n        1002,\r\n        \"WS_ERR_UNEXPECTED_MASK\"\r\n      );\r\n    }\r\n    if (this._payloadLength === 126)\r\n      this._state = GET_PAYLOAD_LENGTH_16;\r\n    else if (this._payloadLength === 127)\r\n      this._state = GET_PAYLOAD_LENGTH_64;\r\n    else\r\n      return this.haveLength();\r\n  }\r\n  /**\r\n   * Gets extended payload length (7+16).\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  getPayloadLength16() {\r\n    if (this._bufferedBytes < 2) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n    this._payloadLength = this.consume(2).readUInt16BE(0);\r\n    return this.haveLength();\r\n  }\r\n  /**\r\n   * Gets extended payload length (7+64).\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  getPayloadLength64() {\r\n    if (this._bufferedBytes < 8) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n    const buf = this.consume(8);\r\n    const num = buf.readUInt32BE(0);\r\n    if (num > Math.pow(2, 53 - 32) - 1) {\r\n      this._loop = false;\r\n      return error(\r\n        RangeError,\r\n        \"Unsupported WebSocket frame: payload length > 2^53 - 1\",\r\n        false,\r\n        1009,\r\n        \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\"\r\n      );\r\n    }\r\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\r\n    return this.haveLength();\r\n  }\r\n  /**\r\n   * Payload length has been read.\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  haveLength() {\r\n    if (this._payloadLength && this._opcode < 8) {\r\n      this._totalPayloadLength += this._payloadLength;\r\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\r\n        this._loop = false;\r\n        return error(\r\n          RangeError,\r\n          \"Max payload size exceeded\",\r\n          false,\r\n          1009,\r\n          \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"\r\n        );\r\n      }\r\n    }\r\n    if (this._masked)\r\n      this._state = GET_MASK;\r\n    else\r\n      this._state = GET_DATA;\r\n  }\r\n  /**\r\n   * Reads mask bytes.\r\n   *\r\n   * @private\r\n   */\r\n  getMask() {\r\n    if (this._bufferedBytes < 4) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n    this._mask = this.consume(4);\r\n    this._state = GET_DATA;\r\n  }\r\n  /**\r\n   * Reads data bytes.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @return {(Error|RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  getData(cb) {\r\n    let data = EMPTY_BUFFER$2;\r\n    if (this._payloadLength) {\r\n      if (this._bufferedBytes < this._payloadLength) {\r\n        this._loop = false;\r\n        return;\r\n      }\r\n      data = this.consume(this._payloadLength);\r\n      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\r\n        unmask(data, this._mask);\r\n      }\r\n    }\r\n    if (this._opcode > 7)\r\n      return this.controlMessage(data);\r\n    if (this._compressed) {\r\n      this._state = INFLATING;\r\n      this.decompress(data, cb);\r\n      return;\r\n    }\r\n    if (data.length) {\r\n      this._messageLength = this._totalPayloadLength;\r\n      this._fragments.push(data);\r\n    }\r\n    return this.dataMessage();\r\n  }\r\n  /**\r\n   * Decompresses data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  decompress(data, cb) {\r\n    const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];\r\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\r\n      if (err)\r\n        return cb(err);\r\n      if (buf.length) {\r\n        this._messageLength += buf.length;\r\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\r\n          return cb(\r\n            error(\r\n              RangeError,\r\n              \"Max payload size exceeded\",\r\n              false,\r\n              1009,\r\n              \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"\r\n            )\r\n          );\r\n        }\r\n        this._fragments.push(buf);\r\n      }\r\n      const er = this.dataMessage();\r\n      if (er)\r\n        return cb(er);\r\n      this.startLoop(cb);\r\n    });\r\n  }\r\n  /**\r\n   * Handles a data message.\r\n   *\r\n   * @return {(Error|undefined)} A possible error\r\n   * @private\r\n   */\r\n  dataMessage() {\r\n    if (this._fin) {\r\n      const messageLength = this._messageLength;\r\n      const fragments = this._fragments;\r\n      this._totalPayloadLength = 0;\r\n      this._messageLength = 0;\r\n      this._fragmented = 0;\r\n      this._fragments = [];\r\n      if (this._opcode === 2) {\r\n        let data;\r\n        if (this._binaryType === \"nodebuffer\") {\r\n          data = concat(fragments, messageLength);\r\n        } else if (this._binaryType === \"arraybuffer\") {\r\n          data = toArrayBuffer(concat(fragments, messageLength));\r\n        } else {\r\n          data = fragments;\r\n        }\r\n        this.emit(\"message\", data, true);\r\n      } else {\r\n        const buf = concat(fragments, messageLength);\r\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\r\n          this._loop = false;\r\n          return error(\r\n            Error,\r\n            \"invalid UTF-8 sequence\",\r\n            true,\r\n            1007,\r\n            \"WS_ERR_INVALID_UTF8\"\r\n          );\r\n        }\r\n        this.emit(\"message\", buf, false);\r\n      }\r\n    }\r\n    this._state = GET_INFO;\r\n  }\r\n  /**\r\n   * Handles a control message.\r\n   *\r\n   * @param {Buffer} data Data to handle\r\n   * @return {(Error|RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  controlMessage(data) {\r\n    if (this._opcode === 8) {\r\n      this._loop = false;\r\n      if (data.length === 0) {\r\n        this.emit(\"conclude\", 1005, EMPTY_BUFFER$2);\r\n        this.end();\r\n      } else {\r\n        const code = data.readUInt16BE(0);\r\n        if (!isValidStatusCode$1(code)) {\r\n          return error(\r\n            RangeError,\r\n            `invalid status code ${code}`,\r\n            true,\r\n            1002,\r\n            \"WS_ERR_INVALID_CLOSE_CODE\"\r\n          );\r\n        }\r\n        const buf = new FastBuffer(\r\n          data.buffer,\r\n          data.byteOffset + 2,\r\n          data.length - 2\r\n        );\r\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\r\n          return error(\r\n            Error,\r\n            \"invalid UTF-8 sequence\",\r\n            true,\r\n            1007,\r\n            \"WS_ERR_INVALID_UTF8\"\r\n          );\r\n        }\r\n        this.emit(\"conclude\", code, buf);\r\n        this.end();\r\n      }\r\n    } else if (this._opcode === 9) {\r\n      this.emit(\"ping\", data);\r\n    } else {\r\n      this.emit(\"pong\", data);\r\n    }\r\n    this._state = GET_INFO;\r\n  }\r\n};\r\nvar receiver = Receiver$1;\r\nfunction error(ErrorCtor, message, prefix, statusCode, errorCode) {\r\n  const err = new ErrorCtor(\r\n    prefix ? `Invalid WebSocket frame: ${message}` : message\r\n  );\r\n  Error.captureStackTrace(err, error);\r\n  err.code = errorCode;\r\n  err[kStatusCode$1] = statusCode;\r\n  return err;\r\n}\r\nconst receiver$1 = /* @__PURE__ */ getDefaultExportFromCjs(receiver);\r\nconst { randomFillSync } = require$$5;\r\nconst PerMessageDeflate$2 = permessageDeflate;\r\nconst { EMPTY_BUFFER: EMPTY_BUFFER$1 } = constants;\r\nconst { isValidStatusCode } = validationExports;\r\nconst { mask: applyMask, toBuffer: toBuffer$1 } = bufferUtilExports;\r\nconst kByteLength = Symbol(\"kByteLength\");\r\nconst maskBuffer = Buffer.alloc(4);\r\nlet Sender$1 = class Sender {\r\n  /**\r\n   * Creates a Sender instance.\r\n   *\r\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\r\n   * @param {Object} [extensions] An object containing the negotiated extensions\r\n   * @param {Function} [generateMask] The function used to generate the masking\r\n   *     key\r\n   */\r\n  constructor(socket, extensions, generateMask) {\r\n    this._extensions = extensions || {};\r\n    if (generateMask) {\r\n      this._generateMask = generateMask;\r\n      this._maskBuffer = Buffer.alloc(4);\r\n    }\r\n    this._socket = socket;\r\n    this._firstFragment = true;\r\n    this._compress = false;\r\n    this._bufferedBytes = 0;\r\n    this._deflating = false;\r\n    this._queue = [];\r\n  }\r\n  /**\r\n   * Frames a piece of data according to the HyBi WebSocket protocol.\r\n   *\r\n   * @param {(Buffer|String)} data The data to frame\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @return {(Buffer|String)[]} The framed data\r\n   * @public\r\n   */\r\n  static frame(data, options) {\r\n    let mask2;\r\n    let merge = false;\r\n    let offset = 2;\r\n    let skipMasking = false;\r\n    if (options.mask) {\r\n      mask2 = options.maskBuffer || maskBuffer;\r\n      if (options.generateMask) {\r\n        options.generateMask(mask2);\r\n      } else {\r\n        randomFillSync(mask2, 0, 4);\r\n      }\r\n      skipMasking = (mask2[0] | mask2[1] | mask2[2] | mask2[3]) === 0;\r\n      offset = 6;\r\n    }\r\n    let dataLength;\r\n    if (typeof data === \"string\") {\r\n      if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {\r\n        dataLength = options[kByteLength];\r\n      } else {\r\n        data = Buffer.from(data);\r\n        dataLength = data.length;\r\n      }\r\n    } else {\r\n      dataLength = data.length;\r\n      merge = options.mask && options.readOnly && !skipMasking;\r\n    }\r\n    let payloadLength = dataLength;\r\n    if (dataLength >= 65536) {\r\n      offset += 8;\r\n      payloadLength = 127;\r\n    } else if (dataLength > 125) {\r\n      offset += 2;\r\n      payloadLength = 126;\r\n    }\r\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\r\n    target[0] = options.fin ? options.opcode | 128 : options.opcode;\r\n    if (options.rsv1)\r\n      target[0] |= 64;\r\n    target[1] = payloadLength;\r\n    if (payloadLength === 126) {\r\n      target.writeUInt16BE(dataLength, 2);\r\n    } else if (payloadLength === 127) {\r\n      target[2] = target[3] = 0;\r\n      target.writeUIntBE(dataLength, 4, 6);\r\n    }\r\n    if (!options.mask)\r\n      return [target, data];\r\n    target[1] |= 128;\r\n    target[offset - 4] = mask2[0];\r\n    target[offset - 3] = mask2[1];\r\n    target[offset - 2] = mask2[2];\r\n    target[offset - 1] = mask2[3];\r\n    if (skipMasking)\r\n      return [target, data];\r\n    if (merge) {\r\n      applyMask(data, mask2, target, offset, dataLength);\r\n      return [target];\r\n    }\r\n    applyMask(data, mask2, data, 0, dataLength);\r\n    return [target, data];\r\n  }\r\n  /**\r\n   * Sends a close message to the other peer.\r\n   *\r\n   * @param {Number} [code] The status code component of the body\r\n   * @param {(String|Buffer)} [data] The message component of the body\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */\r\n  close(code, data, mask2, cb) {\r\n    let buf;\r\n    if (code === void 0) {\r\n      buf = EMPTY_BUFFER$1;\r\n    } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\r\n      throw new TypeError(\"First argument must be a valid error code number\");\r\n    } else if (data === void 0 || !data.length) {\r\n      buf = Buffer.allocUnsafe(2);\r\n      buf.writeUInt16BE(code, 0);\r\n    } else {\r\n      const length = Buffer.byteLength(data);\r\n      if (length > 123) {\r\n        throw new RangeError(\"The message must not be greater than 123 bytes\");\r\n      }\r\n      buf = Buffer.allocUnsafe(2 + length);\r\n      buf.writeUInt16BE(code, 0);\r\n      if (typeof data === \"string\") {\r\n        buf.write(data, 2);\r\n      } else {\r\n        buf.set(data, 2);\r\n      }\r\n    }\r\n    const options = {\r\n      [kByteLength]: buf.length,\r\n      fin: true,\r\n      generateMask: this._generateMask,\r\n      mask: mask2,\r\n      maskBuffer: this._maskBuffer,\r\n      opcode: 8,\r\n      readOnly: false,\r\n      rsv1: false\r\n    };\r\n    if (this._deflating) {\r\n      this.enqueue([this.dispatch, buf, false, options, cb]);\r\n    } else {\r\n      this.sendFrame(Sender.frame(buf, options), cb);\r\n    }\r\n  }\r\n  /**\r\n   * Sends a ping message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */\r\n  ping(data, mask2, cb) {\r\n    let byteLength;\r\n    let readOnly;\r\n    if (typeof data === \"string\") {\r\n      byteLength = Buffer.byteLength(data);\r\n      readOnly = false;\r\n    } else {\r\n      data = toBuffer$1(data);\r\n      byteLength = data.length;\r\n      readOnly = toBuffer$1.readOnly;\r\n    }\r\n    if (byteLength > 125) {\r\n      throw new RangeError(\"The data size must not be greater than 125 bytes\");\r\n    }\r\n    const options = {\r\n      [kByteLength]: byteLength,\r\n      fin: true,\r\n      generateMask: this._generateMask,\r\n      mask: mask2,\r\n      maskBuffer: this._maskBuffer,\r\n      opcode: 9,\r\n      readOnly,\r\n      rsv1: false\r\n    };\r\n    if (this._deflating) {\r\n      this.enqueue([this.dispatch, data, false, options, cb]);\r\n    } else {\r\n      this.sendFrame(Sender.frame(data, options), cb);\r\n    }\r\n  }\r\n  /**\r\n   * Sends a pong message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */\r\n  pong(data, mask2, cb) {\r\n    let byteLength;\r\n    let readOnly;\r\n    if (typeof data === \"string\") {\r\n      byteLength = Buffer.byteLength(data);\r\n      readOnly = false;\r\n    } else {\r\n      data = toBuffer$1(data);\r\n      byteLength = data.length;\r\n      readOnly = toBuffer$1.readOnly;\r\n    }\r\n    if (byteLength > 125) {\r\n      throw new RangeError(\"The data size must not be greater than 125 bytes\");\r\n    }\r\n    const options = {\r\n      [kByteLength]: byteLength,\r\n      fin: true,\r\n      generateMask: this._generateMask,\r\n      mask: mask2,\r\n      maskBuffer: this._maskBuffer,\r\n      opcode: 10,\r\n      readOnly,\r\n      rsv1: false\r\n    };\r\n    if (this._deflating) {\r\n      this.enqueue([this.dispatch, data, false, options, cb]);\r\n    } else {\r\n      this.sendFrame(Sender.frame(data, options), cb);\r\n    }\r\n  }\r\n  /**\r\n   * Sends a data message to the other peer.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\r\n   *     or text\r\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\r\n   *     compress `data`\r\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\r\n   *     last one\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Function} [cb] Callback\r\n   * @public\r\n   */\r\n  send(data, options, cb) {\r\n    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];\r\n    let opcode = options.binary ? 2 : 1;\r\n    let rsv1 = options.compress;\r\n    let byteLength;\r\n    let readOnly;\r\n    if (typeof data === \"string\") {\r\n      byteLength = Buffer.byteLength(data);\r\n      readOnly = false;\r\n    } else {\r\n      data = toBuffer$1(data);\r\n      byteLength = data.length;\r\n      readOnly = toBuffer$1.readOnly;\r\n    }\r\n    if (this._firstFragment) {\r\n      this._firstFragment = false;\r\n      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\r\n        rsv1 = byteLength >= perMessageDeflate._threshold;\r\n      }\r\n      this._compress = rsv1;\r\n    } else {\r\n      rsv1 = false;\r\n      opcode = 0;\r\n    }\r\n    if (options.fin)\r\n      this._firstFragment = true;\r\n    if (perMessageDeflate) {\r\n      const opts = {\r\n        [kByteLength]: byteLength,\r\n        fin: options.fin,\r\n        generateMask: this._generateMask,\r\n        mask: options.mask,\r\n        maskBuffer: this._maskBuffer,\r\n        opcode,\r\n        readOnly,\r\n        rsv1\r\n      };\r\n      if (this._deflating) {\r\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\r\n      } else {\r\n        this.dispatch(data, this._compress, opts, cb);\r\n      }\r\n    } else {\r\n      this.sendFrame(\r\n        Sender.frame(data, {\r\n          [kByteLength]: byteLength,\r\n          fin: options.fin,\r\n          generateMask: this._generateMask,\r\n          mask: options.mask,\r\n          maskBuffer: this._maskBuffer,\r\n          opcode,\r\n          readOnly,\r\n          rsv1: false\r\n        }),\r\n        cb\r\n      );\r\n    }\r\n  }\r\n  /**\r\n   * Dispatches a message.\r\n   *\r\n   * @param {(Buffer|String)} data The message to send\r\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\r\n   *     `data`\r\n   * @param {Object} options Options object\r\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\r\n   *     FIN bit\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\r\n   *     `data`\r\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\r\n   *     key\r\n   * @param {Number} options.opcode The opcode\r\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\r\n   *     modified\r\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\r\n   *     RSV1 bit\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */\r\n  dispatch(data, compress, options, cb) {\r\n    if (!compress) {\r\n      this.sendFrame(Sender.frame(data, options), cb);\r\n      return;\r\n    }\r\n    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];\r\n    this._bufferedBytes += options[kByteLength];\r\n    this._deflating = true;\r\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\r\n      if (this._socket.destroyed) {\r\n        const err = new Error(\r\n          \"The socket was closed while data was being compressed\"\r\n        );\r\n        if (typeof cb === \"function\")\r\n          cb(err);\r\n        for (let i = 0; i < this._queue.length; i++) {\r\n          const params = this._queue[i];\r\n          const callback = params[params.length - 1];\r\n          if (typeof callback === \"function\")\r\n            callback(err);\r\n        }\r\n        return;\r\n      }\r\n      this._bufferedBytes -= options[kByteLength];\r\n      this._deflating = false;\r\n      options.readOnly = false;\r\n      this.sendFrame(Sender.frame(buf, options), cb);\r\n      this.dequeue();\r\n    });\r\n  }\r\n  /**\r\n   * Executes queued send operations.\r\n   *\r\n   * @private\r\n   */\r\n  dequeue() {\r\n    while (!this._deflating && this._queue.length) {\r\n      const params = this._queue.shift();\r\n      this._bufferedBytes -= params[3][kByteLength];\r\n      Reflect.apply(params[0], this, params.slice(1));\r\n    }\r\n  }\r\n  /**\r\n   * Enqueues a send operation.\r\n   *\r\n   * @param {Array} params Send operation parameters.\r\n   * @private\r\n   */\r\n  enqueue(params) {\r\n    this._bufferedBytes += params[3][kByteLength];\r\n    this._queue.push(params);\r\n  }\r\n  /**\r\n   * Sends a frame.\r\n   *\r\n   * @param {Buffer[]} list The frame to send\r\n   * @param {Function} [cb] Callback\r\n   * @private\r\n   */\r\n  sendFrame(list, cb) {\r\n    if (list.length === 2) {\r\n      this._socket.cork();\r\n      this._socket.write(list[0]);\r\n      this._socket.write(list[1], cb);\r\n      this._socket.uncork();\r\n    } else {\r\n      this._socket.write(list[0], cb);\r\n    }\r\n  }\r\n};\r\nvar sender = Sender$1;\r\nconst sender$1 = /* @__PURE__ */ getDefaultExportFromCjs(sender);\r\nconst { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants;\r\nconst kCode = Symbol(\"kCode\");\r\nconst kData = Symbol(\"kData\");\r\nconst kError = Symbol(\"kError\");\r\nconst kMessage = Symbol(\"kMessage\");\r\nconst kReason = Symbol(\"kReason\");\r\nconst kTarget = Symbol(\"kTarget\");\r\nconst kType = Symbol(\"kType\");\r\nconst kWasClean = Symbol(\"kWasClean\");\r\nclass Event {\r\n  /**\r\n   * Create a new `Event`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @throws {TypeError} If the `type` argument is not specified\r\n   */\r\n  constructor(type) {\r\n    this[kTarget] = null;\r\n    this[kType] = type;\r\n  }\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get target() {\r\n    return this[kTarget];\r\n  }\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get type() {\r\n    return this[kType];\r\n  }\r\n}\r\nObject.defineProperty(Event.prototype, \"target\", { enumerable: true });\r\nObject.defineProperty(Event.prototype, \"type\", { enumerable: true });\r\nclass CloseEvent extends Event {\r\n  /**\r\n   * Create a new `CloseEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {Number} [options.code=0] The status code explaining why the\r\n   *     connection was closed\r\n   * @param {String} [options.reason=''] A human-readable string explaining why\r\n   *     the connection was closed\r\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\r\n   *     connection was cleanly closed\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n    this[kCode] = options.code === void 0 ? 0 : options.code;\r\n    this[kReason] = options.reason === void 0 ? \"\" : options.reason;\r\n    this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;\r\n  }\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get code() {\r\n    return this[kCode];\r\n  }\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get reason() {\r\n    return this[kReason];\r\n  }\r\n  /**\r\n   * @type {Boolean}\r\n   */\r\n  get wasClean() {\r\n    return this[kWasClean];\r\n  }\r\n}\r\nObject.defineProperty(CloseEvent.prototype, \"code\", { enumerable: true });\r\nObject.defineProperty(CloseEvent.prototype, \"reason\", { enumerable: true });\r\nObject.defineProperty(CloseEvent.prototype, \"wasClean\", { enumerable: true });\r\nclass ErrorEvent extends Event {\r\n  /**\r\n   * Create a new `ErrorEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {*} [options.error=null] The error that generated this event\r\n   * @param {String} [options.message=''] The error message\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n    this[kError] = options.error === void 0 ? null : options.error;\r\n    this[kMessage] = options.message === void 0 ? \"\" : options.message;\r\n  }\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get error() {\r\n    return this[kError];\r\n  }\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get message() {\r\n    return this[kMessage];\r\n  }\r\n}\r\nObject.defineProperty(ErrorEvent.prototype, \"error\", { enumerable: true });\r\nObject.defineProperty(ErrorEvent.prototype, \"message\", { enumerable: true });\r\nclass MessageEvent extends Event {\r\n  /**\r\n   * Create a new `MessageEvent`.\r\n   *\r\n   * @param {String} type The name of the event\r\n   * @param {Object} [options] A dictionary object that allows for setting\r\n   *     attributes via object members of the same name\r\n   * @param {*} [options.data=null] The message content\r\n   */\r\n  constructor(type, options = {}) {\r\n    super(type);\r\n    this[kData] = options.data === void 0 ? null : options.data;\r\n  }\r\n  /**\r\n   * @type {*}\r\n   */\r\n  get data() {\r\n    return this[kData];\r\n  }\r\n}\r\nObject.defineProperty(MessageEvent.prototype, \"data\", { enumerable: true });\r\nconst EventTarget = {\r\n  /**\r\n   * Register an event listener.\r\n   *\r\n   * @param {String} type A string representing the event type to listen for\r\n   * @param {(Function|Object)} handler The listener to add\r\n   * @param {Object} [options] An options object specifies characteristics about\r\n   *     the event listener\r\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\r\n   *     listener should be invoked at most once after being added. If `true`,\r\n   *     the listener would be automatically removed when invoked.\r\n   * @public\r\n   */\r\n  addEventListener(type, handler, options = {}) {\r\n    for (const listener of this.listeners(type)) {\r\n      if (!options[kForOnEventAttribute$1] && listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {\r\n        return;\r\n      }\r\n    }\r\n    let wrapper;\r\n    if (type === \"message\") {\r\n      wrapper = function onMessage(data, isBinary) {\r\n        const event = new MessageEvent(\"message\", {\r\n          data: isBinary ? data : data.toString()\r\n        });\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === \"close\") {\r\n      wrapper = function onClose(code, message) {\r\n        const event = new CloseEvent(\"close\", {\r\n          code,\r\n          reason: message.toString(),\r\n          wasClean: this._closeFrameReceived && this._closeFrameSent\r\n        });\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === \"error\") {\r\n      wrapper = function onError(error2) {\r\n        const event = new ErrorEvent(\"error\", {\r\n          error: error2,\r\n          message: error2.message\r\n        });\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else if (type === \"open\") {\r\n      wrapper = function onOpen() {\r\n        const event = new Event(\"open\");\r\n        event[kTarget] = this;\r\n        callListener(handler, this, event);\r\n      };\r\n    } else {\r\n      return;\r\n    }\r\n    wrapper[kForOnEventAttribute$1] = !!options[kForOnEventAttribute$1];\r\n    wrapper[kListener$1] = handler;\r\n    if (options.once) {\r\n      this.once(type, wrapper);\r\n    } else {\r\n      this.on(type, wrapper);\r\n    }\r\n  },\r\n  /**\r\n   * Remove an event listener.\r\n   *\r\n   * @param {String} type A string representing the event type to remove\r\n   * @param {(Function|Object)} handler The listener to remove\r\n   * @public\r\n   */\r\n  removeEventListener(type, handler) {\r\n    for (const listener of this.listeners(type)) {\r\n      if (listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {\r\n        this.removeListener(type, listener);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\nvar eventTarget = {\r\n  CloseEvent,\r\n  ErrorEvent,\r\n  Event,\r\n  EventTarget,\r\n  MessageEvent\r\n};\r\nfunction callListener(listener, thisArg, event) {\r\n  if (typeof listener === \"object\" && listener.handleEvent) {\r\n    listener.handleEvent.call(listener, event);\r\n  } else {\r\n    listener.call(thisArg, event);\r\n  }\r\n}\r\nconst { tokenChars: tokenChars$1 } = validationExports;\r\nfunction push(dest, name, elem) {\r\n  if (dest[name] === void 0)\r\n    dest[name] = [elem];\r\n  else\r\n    dest[name].push(elem);\r\n}\r\nfunction parse$2(header) {\r\n  const offers = /* @__PURE__ */ Object.create(null);\r\n  let params = /* @__PURE__ */ Object.create(null);\r\n  let mustUnescape = false;\r\n  let isEscaping = false;\r\n  let inQuotes = false;\r\n  let extensionName;\r\n  let paramName;\r\n  let start = -1;\r\n  let code = -1;\r\n  let end = -1;\r\n  let i = 0;\r\n  for (; i < header.length; i++) {\r\n    code = header.charCodeAt(i);\r\n    if (extensionName === void 0) {\r\n      if (end === -1 && tokenChars$1[code] === 1) {\r\n        if (start === -1)\r\n          start = i;\r\n      } else if (i !== 0 && (code === 32 || code === 9)) {\r\n        if (end === -1 && start !== -1)\r\n          end = i;\r\n      } else if (code === 59 || code === 44) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n        if (end === -1)\r\n          end = i;\r\n        const name = header.slice(start, end);\r\n        if (code === 44) {\r\n          push(offers, name, params);\r\n          params = /* @__PURE__ */ Object.create(null);\r\n        } else {\r\n          extensionName = name;\r\n        }\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    } else if (paramName === void 0) {\r\n      if (end === -1 && tokenChars$1[code] === 1) {\r\n        if (start === -1)\r\n          start = i;\r\n      } else if (code === 32 || code === 9) {\r\n        if (end === -1 && start !== -1)\r\n          end = i;\r\n      } else if (code === 59 || code === 44) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n        if (end === -1)\r\n          end = i;\r\n        push(params, header.slice(start, end), true);\r\n        if (code === 44) {\r\n          push(offers, extensionName, params);\r\n          params = /* @__PURE__ */ Object.create(null);\r\n          extensionName = void 0;\r\n        }\r\n        start = end = -1;\r\n      } else if (code === 61 && start !== -1 && end === -1) {\r\n        paramName = header.slice(start, i);\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    } else {\r\n      if (isEscaping) {\r\n        if (tokenChars$1[code] !== 1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n        if (start === -1)\r\n          start = i;\r\n        else if (!mustUnescape)\r\n          mustUnescape = true;\r\n        isEscaping = false;\r\n      } else if (inQuotes) {\r\n        if (tokenChars$1[code] === 1) {\r\n          if (start === -1)\r\n            start = i;\r\n        } else if (code === 34 && start !== -1) {\r\n          inQuotes = false;\r\n          end = i;\r\n        } else if (code === 92) {\r\n          isEscaping = true;\r\n        } else {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n      } else if (code === 34 && header.charCodeAt(i - 1) === 61) {\r\n        inQuotes = true;\r\n      } else if (end === -1 && tokenChars$1[code] === 1) {\r\n        if (start === -1)\r\n          start = i;\r\n      } else if (start !== -1 && (code === 32 || code === 9)) {\r\n        if (end === -1)\r\n          end = i;\r\n      } else if (code === 59 || code === 44) {\r\n        if (start === -1) {\r\n          throw new SyntaxError(`Unexpected character at index ${i}`);\r\n        }\r\n        if (end === -1)\r\n          end = i;\r\n        let value = header.slice(start, end);\r\n        if (mustUnescape) {\r\n          value = value.replace(/\\\\/g, \"\");\r\n          mustUnescape = false;\r\n        }\r\n        push(params, paramName, value);\r\n        if (code === 44) {\r\n          push(offers, extensionName, params);\r\n          params = /* @__PURE__ */ Object.create(null);\r\n          extensionName = void 0;\r\n        }\r\n        paramName = void 0;\r\n        start = end = -1;\r\n      } else {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n    }\r\n  }\r\n  if (start === -1 || inQuotes || code === 32 || code === 9) {\r\n    throw new SyntaxError(\"Unexpected end of input\");\r\n  }\r\n  if (end === -1)\r\n    end = i;\r\n  const token = header.slice(start, end);\r\n  if (extensionName === void 0) {\r\n    push(offers, token, params);\r\n  } else {\r\n    if (paramName === void 0) {\r\n      push(params, token, true);\r\n    } else if (mustUnescape) {\r\n      push(params, paramName, token.replace(/\\\\/g, \"\"));\r\n    } else {\r\n      push(params, paramName, token);\r\n    }\r\n    push(offers, extensionName, params);\r\n  }\r\n  return offers;\r\n}\r\nfunction format$1(extensions) {\r\n  return Object.keys(extensions).map((extension2) => {\r\n    let configurations = extensions[extension2];\r\n    if (!Array.isArray(configurations))\r\n      configurations = [configurations];\r\n    return configurations.map((params) => {\r\n      return [extension2].concat(\r\n        Object.keys(params).map((k) => {\r\n          let values = params[k];\r\n          if (!Array.isArray(values))\r\n            values = [values];\r\n          return values.map((v) => v === true ? k : `${k}=${v}`).join(\"; \");\r\n        })\r\n      ).join(\"; \");\r\n    }).join(\", \");\r\n  }).join(\", \");\r\n}\r\nvar extension$1 = { format: format$1, parse: parse$2 };\r\nconst EventEmitter$1 = require$$0$3;\r\nconst https = require$$1$1;\r\nconst http$1 = require$$2;\r\nconst net = require$$3;\r\nconst tls = require$$4;\r\nconst { randomBytes, createHash: createHash$1 } = require$$5;\r\nconst { URL } = require$$7;\r\nconst PerMessageDeflate$1 = permessageDeflate;\r\nconst Receiver2 = receiver;\r\nconst Sender2 = sender;\r\nconst {\r\n  BINARY_TYPES,\r\n  EMPTY_BUFFER,\r\n  GUID: GUID$1,\r\n  kForOnEventAttribute,\r\n  kListener,\r\n  kStatusCode,\r\n  kWebSocket: kWebSocket$1,\r\n  NOOP\r\n} = constants;\r\nconst {\r\n  EventTarget: { addEventListener, removeEventListener }\r\n} = eventTarget;\r\nconst { format, parse: parse$1 } = extension$1;\r\nconst { toBuffer } = bufferUtilExports;\r\nconst closeTimeout = 30 * 1e3;\r\nconst kAborted = Symbol(\"kAborted\");\r\nconst protocolVersions = [8, 13];\r\nconst readyStates = [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"];\r\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\r\nlet WebSocket$1 = class WebSocket extends EventEmitter$1 {\r\n  /**\r\n   * Create a new `WebSocket`.\r\n   *\r\n   * @param {(String|URL)} address The URL to which to connect\r\n   * @param {(String|String[])} [protocols] The subprotocols\r\n   * @param {Object} [options] Connection options\r\n   */\r\n  constructor(address, protocols, options) {\r\n    super();\r\n    this._binaryType = BINARY_TYPES[0];\r\n    this._closeCode = 1006;\r\n    this._closeFrameReceived = false;\r\n    this._closeFrameSent = false;\r\n    this._closeMessage = EMPTY_BUFFER;\r\n    this._closeTimer = null;\r\n    this._extensions = {};\r\n    this._paused = false;\r\n    this._protocol = \"\";\r\n    this._readyState = WebSocket.CONNECTING;\r\n    this._receiver = null;\r\n    this._sender = null;\r\n    this._socket = null;\r\n    if (address !== null) {\r\n      this._bufferedAmount = 0;\r\n      this._isServer = false;\r\n      this._redirects = 0;\r\n      if (protocols === void 0) {\r\n        protocols = [];\r\n      } else if (!Array.isArray(protocols)) {\r\n        if (typeof protocols === \"object\" && protocols !== null) {\r\n          options = protocols;\r\n          protocols = [];\r\n        } else {\r\n          protocols = [protocols];\r\n        }\r\n      }\r\n      initAsClient(this, address, protocols, options);\r\n    } else {\r\n      this._isServer = true;\r\n    }\r\n  }\r\n  /**\r\n   * This deviates from the WHATWG interface since ws doesn't support the\r\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\r\n   * type).\r\n   *\r\n   * @type {String}\r\n   */\r\n  get binaryType() {\r\n    return this._binaryType;\r\n  }\r\n  set binaryType(type) {\r\n    if (!BINARY_TYPES.includes(type))\r\n      return;\r\n    this._binaryType = type;\r\n    if (this._receiver)\r\n      this._receiver._binaryType = type;\r\n  }\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get bufferedAmount() {\r\n    if (!this._socket)\r\n      return this._bufferedAmount;\r\n    return this._socket._writableState.length + this._sender._bufferedBytes;\r\n  }\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get extensions() {\r\n    return Object.keys(this._extensions).join();\r\n  }\r\n  /**\r\n   * @type {Boolean}\r\n   */\r\n  get isPaused() {\r\n    return this._paused;\r\n  }\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onclose() {\r\n    return null;\r\n  }\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onerror() {\r\n    return null;\r\n  }\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onopen() {\r\n    return null;\r\n  }\r\n  /**\r\n   * @type {Function}\r\n   */\r\n  /* istanbul ignore next */\r\n  get onmessage() {\r\n    return null;\r\n  }\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get protocol() {\r\n    return this._protocol;\r\n  }\r\n  /**\r\n   * @type {Number}\r\n   */\r\n  get readyState() {\r\n    return this._readyState;\r\n  }\r\n  /**\r\n   * @type {String}\r\n   */\r\n  get url() {\r\n    return this._url;\r\n  }\r\n  /**\r\n   * Set up the socket and the internal resources.\r\n   *\r\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\r\n   *     server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Object} options Options object\r\n   * @param {Function} [options.generateMask] The function used to generate the\r\n   *     masking key\r\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   * @private\r\n   */\r\n  setSocket(socket, head, options) {\r\n    const receiver2 = new Receiver2({\r\n      binaryType: this.binaryType,\r\n      extensions: this._extensions,\r\n      isServer: this._isServer,\r\n      maxPayload: options.maxPayload,\r\n      skipUTF8Validation: options.skipUTF8Validation\r\n    });\r\n    this._sender = new Sender2(socket, this._extensions, options.generateMask);\r\n    this._receiver = receiver2;\r\n    this._socket = socket;\r\n    receiver2[kWebSocket$1] = this;\r\n    socket[kWebSocket$1] = this;\r\n    receiver2.on(\"conclude\", receiverOnConclude);\r\n    receiver2.on(\"drain\", receiverOnDrain);\r\n    receiver2.on(\"error\", receiverOnError);\r\n    receiver2.on(\"message\", receiverOnMessage);\r\n    receiver2.on(\"ping\", receiverOnPing);\r\n    receiver2.on(\"pong\", receiverOnPong);\r\n    socket.setTimeout(0);\r\n    socket.setNoDelay();\r\n    if (head.length > 0)\r\n      socket.unshift(head);\r\n    socket.on(\"close\", socketOnClose);\r\n    socket.on(\"data\", socketOnData);\r\n    socket.on(\"end\", socketOnEnd);\r\n    socket.on(\"error\", socketOnError$1);\r\n    this._readyState = WebSocket.OPEN;\r\n    this.emit(\"open\");\r\n  }\r\n  /**\r\n   * Emit the `'close'` event.\r\n   *\r\n   * @private\r\n   */\r\n  emitClose() {\r\n    if (!this._socket) {\r\n      this._readyState = WebSocket.CLOSED;\r\n      this.emit(\"close\", this._closeCode, this._closeMessage);\r\n      return;\r\n    }\r\n    if (this._extensions[PerMessageDeflate$1.extensionName]) {\r\n      this._extensions[PerMessageDeflate$1.extensionName].cleanup();\r\n    }\r\n    this._receiver.removeAllListeners();\r\n    this._readyState = WebSocket.CLOSED;\r\n    this.emit(\"close\", this._closeCode, this._closeMessage);\r\n  }\r\n  /**\r\n   * Start a closing handshake.\r\n   *\r\n   *          +----------+   +-----------+   +----------+\r\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\r\n   *    |     +----------+   +-----------+   +----------+     |\r\n   *          +----------+   +-----------+         |\r\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\r\n   *          +----------+   +-----------+   |\r\n   *    |           |                        |   +---+        |\r\n   *                +------------------------+-->|fin| - - - -\r\n   *    |         +---+                      |   +---+\r\n   *     - - - - -|fin|<---------------------+\r\n   *              +---+\r\n   *\r\n   * @param {Number} [code] Status code explaining why the connection is closing\r\n   * @param {(String|Buffer)} [data] The reason why the connection is\r\n   *     closing\r\n   * @public\r\n   */\r\n  close(code, data) {\r\n    if (this.readyState === WebSocket.CLOSED)\r\n      return;\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      const msg = \"WebSocket was closed before the connection was established\";\r\n      abortHandshake$1(this, this._req, msg);\r\n      return;\r\n    }\r\n    if (this.readyState === WebSocket.CLOSING) {\r\n      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\r\n        this._socket.end();\r\n      }\r\n      return;\r\n    }\r\n    this._readyState = WebSocket.CLOSING;\r\n    this._sender.close(code, data, !this._isServer, (err) => {\r\n      if (err)\r\n        return;\r\n      this._closeFrameSent = true;\r\n      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\r\n        this._socket.end();\r\n      }\r\n    });\r\n    this._closeTimer = setTimeout(\r\n      this._socket.destroy.bind(this._socket),\r\n      closeTimeout\r\n    );\r\n  }\r\n  /**\r\n   * Pause the socket.\r\n   *\r\n   * @public\r\n   */\r\n  pause() {\r\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\r\n      return;\r\n    }\r\n    this._paused = true;\r\n    this._socket.pause();\r\n  }\r\n  /**\r\n   * Send a ping.\r\n   *\r\n   * @param {*} [data] The data to send\r\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when the ping is sent\r\n   * @public\r\n   */\r\n  ping(data, mask2, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\r\n    }\r\n    if (typeof data === \"function\") {\r\n      cb = data;\r\n      data = mask2 = void 0;\r\n    } else if (typeof mask2 === \"function\") {\r\n      cb = mask2;\r\n      mask2 = void 0;\r\n    }\r\n    if (typeof data === \"number\")\r\n      data = data.toString();\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n    if (mask2 === void 0)\r\n      mask2 = !this._isServer;\r\n    this._sender.ping(data || EMPTY_BUFFER, mask2, cb);\r\n  }\r\n  /**\r\n   * Send a pong.\r\n   *\r\n   * @param {*} [data] The data to send\r\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when the pong is sent\r\n   * @public\r\n   */\r\n  pong(data, mask2, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\r\n    }\r\n    if (typeof data === \"function\") {\r\n      cb = data;\r\n      data = mask2 = void 0;\r\n    } else if (typeof mask2 === \"function\") {\r\n      cb = mask2;\r\n      mask2 = void 0;\r\n    }\r\n    if (typeof data === \"number\")\r\n      data = data.toString();\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n    if (mask2 === void 0)\r\n      mask2 = !this._isServer;\r\n    this._sender.pong(data || EMPTY_BUFFER, mask2, cb);\r\n  }\r\n  /**\r\n   * Resume the socket.\r\n   *\r\n   * @public\r\n   */\r\n  resume() {\r\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\r\n      return;\r\n    }\r\n    this._paused = false;\r\n    if (!this._receiver._writableState.needDrain)\r\n      this._socket.resume();\r\n  }\r\n  /**\r\n   * Send a data message.\r\n   *\r\n   * @param {*} data The message to send\r\n   * @param {Object} [options] Options object\r\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\r\n   *     text\r\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\r\n   *     `data`\r\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\r\n   *     last one\r\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\r\n   * @param {Function} [cb] Callback which is executed when data is written out\r\n   * @public\r\n   */\r\n  send(data, options, cb) {\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\r\n    }\r\n    if (typeof options === \"function\") {\r\n      cb = options;\r\n      options = {};\r\n    }\r\n    if (typeof data === \"number\")\r\n      data = data.toString();\r\n    if (this.readyState !== WebSocket.OPEN) {\r\n      sendAfterClose(this, data, cb);\r\n      return;\r\n    }\r\n    const opts = {\r\n      binary: typeof data !== \"string\",\r\n      mask: !this._isServer,\r\n      compress: true,\r\n      fin: true,\r\n      ...options\r\n    };\r\n    if (!this._extensions[PerMessageDeflate$1.extensionName]) {\r\n      opts.compress = false;\r\n    }\r\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\r\n  }\r\n  /**\r\n   * Forcibly close the connection.\r\n   *\r\n   * @public\r\n   */\r\n  terminate() {\r\n    if (this.readyState === WebSocket.CLOSED)\r\n      return;\r\n    if (this.readyState === WebSocket.CONNECTING) {\r\n      const msg = \"WebSocket was closed before the connection was established\";\r\n      abortHandshake$1(this, this._req, msg);\r\n      return;\r\n    }\r\n    if (this._socket) {\r\n      this._readyState = WebSocket.CLOSING;\r\n      this._socket.destroy();\r\n    }\r\n  }\r\n};\r\nObject.defineProperty(WebSocket$1, \"CONNECTING\", {\r\n  enumerable: true,\r\n  value: readyStates.indexOf(\"CONNECTING\")\r\n});\r\nObject.defineProperty(WebSocket$1.prototype, \"CONNECTING\", {\r\n  enumerable: true,\r\n  value: readyStates.indexOf(\"CONNECTING\")\r\n});\r\nObject.defineProperty(WebSocket$1, \"OPEN\", {\r\n  enumerable: true,\r\n  value: readyStates.indexOf(\"OPEN\")\r\n});\r\nObject.defineProperty(WebSocket$1.prototype, \"OPEN\", {\r\n  enumerable: true,\r\n  value: readyStates.indexOf(\"OPEN\")\r\n});\r\nObject.defineProperty(WebSocket$1, \"CLOSING\", {\r\n  enumerable: true,\r\n  value: readyStates.indexOf(\"CLOSING\")\r\n});\r\nObject.defineProperty(WebSocket$1.prototype, \"CLOSING\", {\r\n  enumerable: true,\r\n  value: readyStates.indexOf(\"CLOSING\")\r\n});\r\nObject.defineProperty(WebSocket$1, \"CLOSED\", {\r\n  enumerable: true,\r\n  value: readyStates.indexOf(\"CLOSED\")\r\n});\r\nObject.defineProperty(WebSocket$1.prototype, \"CLOSED\", {\r\n  enumerable: true,\r\n  value: readyStates.indexOf(\"CLOSED\")\r\n});\r\n[\r\n  \"binaryType\",\r\n  \"bufferedAmount\",\r\n  \"extensions\",\r\n  \"isPaused\",\r\n  \"protocol\",\r\n  \"readyState\",\r\n  \"url\"\r\n].forEach((property) => {\r\n  Object.defineProperty(WebSocket$1.prototype, property, { enumerable: true });\r\n});\r\n[\"open\", \"error\", \"close\", \"message\"].forEach((method) => {\r\n  Object.defineProperty(WebSocket$1.prototype, `on${method}`, {\r\n    enumerable: true,\r\n    get() {\r\n      for (const listener of this.listeners(method)) {\r\n        if (listener[kForOnEventAttribute])\r\n          return listener[kListener];\r\n      }\r\n      return null;\r\n    },\r\n    set(handler) {\r\n      for (const listener of this.listeners(method)) {\r\n        if (listener[kForOnEventAttribute]) {\r\n          this.removeListener(method, listener);\r\n          break;\r\n        }\r\n      }\r\n      if (typeof handler !== \"function\")\r\n        return;\r\n      this.addEventListener(method, handler, {\r\n        [kForOnEventAttribute]: true\r\n      });\r\n    }\r\n  });\r\n});\r\nWebSocket$1.prototype.addEventListener = addEventListener;\r\nWebSocket$1.prototype.removeEventListener = removeEventListener;\r\nvar websocket = WebSocket$1;\r\nfunction initAsClient(websocket2, address, protocols, options) {\r\n  const opts = {\r\n    protocolVersion: protocolVersions[1],\r\n    maxPayload: 100 * 1024 * 1024,\r\n    skipUTF8Validation: false,\r\n    perMessageDeflate: true,\r\n    followRedirects: false,\r\n    maxRedirects: 10,\r\n    ...options,\r\n    createConnection: void 0,\r\n    socketPath: void 0,\r\n    hostname: void 0,\r\n    protocol: void 0,\r\n    timeout: void 0,\r\n    method: \"GET\",\r\n    host: void 0,\r\n    path: void 0,\r\n    port: void 0\r\n  };\r\n  if (!protocolVersions.includes(opts.protocolVersion)) {\r\n    throw new RangeError(\r\n      `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(\", \")})`\r\n    );\r\n  }\r\n  let parsedUrl;\r\n  if (address instanceof URL) {\r\n    parsedUrl = address;\r\n    websocket2._url = address.href;\r\n  } else {\r\n    try {\r\n      parsedUrl = new URL(address);\r\n    } catch (e) {\r\n      throw new SyntaxError(`Invalid URL: ${address}`);\r\n    }\r\n    websocket2._url = address;\r\n  }\r\n  const isSecure = parsedUrl.protocol === \"wss:\";\r\n  const isIpcUrl = parsedUrl.protocol === \"ws+unix:\";\r\n  let invalidUrlMessage;\r\n  if (parsedUrl.protocol !== \"ws:\" && !isSecure && !isIpcUrl) {\r\n    invalidUrlMessage = `The URL's protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"`;\r\n  } else if (isIpcUrl && !parsedUrl.pathname) {\r\n    invalidUrlMessage = \"The URL's pathname is empty\";\r\n  } else if (parsedUrl.hash) {\r\n    invalidUrlMessage = \"The URL contains a fragment identifier\";\r\n  }\r\n  if (invalidUrlMessage) {\r\n    const err = new SyntaxError(invalidUrlMessage);\r\n    if (websocket2._redirects === 0) {\r\n      throw err;\r\n    } else {\r\n      emitErrorAndClose(websocket2, err);\r\n      return;\r\n    }\r\n  }\r\n  const defaultPort = isSecure ? 443 : 80;\r\n  const key = randomBytes(16).toString(\"base64\");\r\n  const request = isSecure ? https.request : http$1.request;\r\n  const protocolSet = /* @__PURE__ */ new Set();\r\n  let perMessageDeflate;\r\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\r\n  opts.defaultPort = opts.defaultPort || defaultPort;\r\n  opts.port = parsedUrl.port || defaultPort;\r\n  opts.host = parsedUrl.hostname.startsWith(\"[\") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\r\n  opts.headers = {\r\n    ...opts.headers,\r\n    \"Sec-WebSocket-Version\": opts.protocolVersion,\r\n    \"Sec-WebSocket-Key\": key,\r\n    Connection: \"Upgrade\",\r\n    Upgrade: \"websocket\"\r\n  };\r\n  opts.path = parsedUrl.pathname + parsedUrl.search;\r\n  opts.timeout = opts.handshakeTimeout;\r\n  if (opts.perMessageDeflate) {\r\n    perMessageDeflate = new PerMessageDeflate$1(\r\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\r\n      false,\r\n      opts.maxPayload\r\n    );\r\n    opts.headers[\"Sec-WebSocket-Extensions\"] = format({\r\n      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()\r\n    });\r\n  }\r\n  if (protocols.length) {\r\n    for (const protocol of protocols) {\r\n      if (typeof protocol !== \"string\" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\r\n        throw new SyntaxError(\r\n          \"An invalid or duplicated subprotocol was specified\"\r\n        );\r\n      }\r\n      protocolSet.add(protocol);\r\n    }\r\n    opts.headers[\"Sec-WebSocket-Protocol\"] = protocols.join(\",\");\r\n  }\r\n  if (opts.origin) {\r\n    if (opts.protocolVersion < 13) {\r\n      opts.headers[\"Sec-WebSocket-Origin\"] = opts.origin;\r\n    } else {\r\n      opts.headers.Origin = opts.origin;\r\n    }\r\n  }\r\n  if (parsedUrl.username || parsedUrl.password) {\r\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\r\n  }\r\n  if (isIpcUrl) {\r\n    const parts = opts.path.split(\":\");\r\n    opts.socketPath = parts[0];\r\n    opts.path = parts[1];\r\n  }\r\n  let req;\r\n  if (opts.followRedirects) {\r\n    if (websocket2._redirects === 0) {\r\n      websocket2._originalIpc = isIpcUrl;\r\n      websocket2._originalSecure = isSecure;\r\n      websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\r\n      const headers = options && options.headers;\r\n      options = { ...options, headers: {} };\r\n      if (headers) {\r\n        for (const [key2, value] of Object.entries(headers)) {\r\n          options.headers[key2.toLowerCase()] = value;\r\n        }\r\n      }\r\n    } else if (websocket2.listenerCount(\"redirect\") === 0) {\r\n      const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;\r\n      if (!isSameHost || websocket2._originalSecure && !isSecure) {\r\n        delete opts.headers.authorization;\r\n        delete opts.headers.cookie;\r\n        if (!isSameHost)\r\n          delete opts.headers.host;\r\n        opts.auth = void 0;\r\n      }\r\n    }\r\n    if (opts.auth && !options.headers.authorization) {\r\n      options.headers.authorization = \"Basic \" + Buffer.from(opts.auth).toString(\"base64\");\r\n    }\r\n    req = websocket2._req = request(opts);\r\n    if (websocket2._redirects) {\r\n      websocket2.emit(\"redirect\", websocket2.url, req);\r\n    }\r\n  } else {\r\n    req = websocket2._req = request(opts);\r\n  }\r\n  if (opts.timeout) {\r\n    req.on(\"timeout\", () => {\r\n      abortHandshake$1(websocket2, req, \"Opening handshake has timed out\");\r\n    });\r\n  }\r\n  req.on(\"error\", (err) => {\r\n    if (req === null || req[kAborted])\r\n      return;\r\n    req = websocket2._req = null;\r\n    emitErrorAndClose(websocket2, err);\r\n  });\r\n  req.on(\"response\", (res) => {\r\n    const location = res.headers.location;\r\n    const statusCode = res.statusCode;\r\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\r\n      if (++websocket2._redirects > opts.maxRedirects) {\r\n        abortHandshake$1(websocket2, req, \"Maximum redirects exceeded\");\r\n        return;\r\n      }\r\n      req.abort();\r\n      let addr;\r\n      try {\r\n        addr = new URL(location, address);\r\n      } catch (e) {\r\n        const err = new SyntaxError(`Invalid URL: ${location}`);\r\n        emitErrorAndClose(websocket2, err);\r\n        return;\r\n      }\r\n      initAsClient(websocket2, addr, protocols, options);\r\n    } else if (!websocket2.emit(\"unexpected-response\", req, res)) {\r\n      abortHandshake$1(\r\n        websocket2,\r\n        req,\r\n        `Unexpected server response: ${res.statusCode}`\r\n      );\r\n    }\r\n  });\r\n  req.on(\"upgrade\", (res, socket, head) => {\r\n    websocket2.emit(\"upgrade\", res);\r\n    if (websocket2.readyState !== WebSocket$1.CONNECTING)\r\n      return;\r\n    req = websocket2._req = null;\r\n    if (res.headers.upgrade.toLowerCase() !== \"websocket\") {\r\n      abortHandshake$1(websocket2, socket, \"Invalid Upgrade header\");\r\n      return;\r\n    }\r\n    const digest = createHash$1(\"sha1\").update(key + GUID$1).digest(\"base64\");\r\n    if (res.headers[\"sec-websocket-accept\"] !== digest) {\r\n      abortHandshake$1(websocket2, socket, \"Invalid Sec-WebSocket-Accept header\");\r\n      return;\r\n    }\r\n    const serverProt = res.headers[\"sec-websocket-protocol\"];\r\n    let protError;\r\n    if (serverProt !== void 0) {\r\n      if (!protocolSet.size) {\r\n        protError = \"Server sent a subprotocol but none was requested\";\r\n      } else if (!protocolSet.has(serverProt)) {\r\n        protError = \"Server sent an invalid subprotocol\";\r\n      }\r\n    } else if (protocolSet.size) {\r\n      protError = \"Server sent no subprotocol\";\r\n    }\r\n    if (protError) {\r\n      abortHandshake$1(websocket2, socket, protError);\r\n      return;\r\n    }\r\n    if (serverProt)\r\n      websocket2._protocol = serverProt;\r\n    const secWebSocketExtensions = res.headers[\"sec-websocket-extensions\"];\r\n    if (secWebSocketExtensions !== void 0) {\r\n      if (!perMessageDeflate) {\r\n        const message = \"Server sent a Sec-WebSocket-Extensions header but no extension was requested\";\r\n        abortHandshake$1(websocket2, socket, message);\r\n        return;\r\n      }\r\n      let extensions;\r\n      try {\r\n        extensions = parse$1(secWebSocketExtensions);\r\n      } catch (err) {\r\n        const message = \"Invalid Sec-WebSocket-Extensions header\";\r\n        abortHandshake$1(websocket2, socket, message);\r\n        return;\r\n      }\r\n      const extensionNames = Object.keys(extensions);\r\n      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {\r\n        const message = \"Server indicated an extension that was not requested\";\r\n        abortHandshake$1(websocket2, socket, message);\r\n        return;\r\n      }\r\n      try {\r\n        perMessageDeflate.accept(extensions[PerMessageDeflate$1.extensionName]);\r\n      } catch (err) {\r\n        const message = \"Invalid Sec-WebSocket-Extensions header\";\r\n        abortHandshake$1(websocket2, socket, message);\r\n        return;\r\n      }\r\n      websocket2._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;\r\n    }\r\n    websocket2.setSocket(socket, head, {\r\n      generateMask: opts.generateMask,\r\n      maxPayload: opts.maxPayload,\r\n      skipUTF8Validation: opts.skipUTF8Validation\r\n    });\r\n  });\r\n  if (opts.finishRequest) {\r\n    opts.finishRequest(req, websocket2);\r\n  } else {\r\n    req.end();\r\n  }\r\n}\r\nfunction emitErrorAndClose(websocket2, err) {\r\n  websocket2._readyState = WebSocket$1.CLOSING;\r\n  websocket2.emit(\"error\", err);\r\n  websocket2.emitClose();\r\n}\r\nfunction netConnect(options) {\r\n  options.path = options.socketPath;\r\n  return net.connect(options);\r\n}\r\nfunction tlsConnect(options) {\r\n  options.path = void 0;\r\n  if (!options.servername && options.servername !== \"\") {\r\n    options.servername = net.isIP(options.host) ? \"\" : options.host;\r\n  }\r\n  return tls.connect(options);\r\n}\r\nfunction abortHandshake$1(websocket2, stream2, message) {\r\n  websocket2._readyState = WebSocket$1.CLOSING;\r\n  const err = new Error(message);\r\n  Error.captureStackTrace(err, abortHandshake$1);\r\n  if (stream2.setHeader) {\r\n    stream2[kAborted] = true;\r\n    stream2.abort();\r\n    if (stream2.socket && !stream2.socket.destroyed) {\r\n      stream2.socket.destroy();\r\n    }\r\n    process.nextTick(emitErrorAndClose, websocket2, err);\r\n  } else {\r\n    stream2.destroy(err);\r\n    stream2.once(\"error\", websocket2.emit.bind(websocket2, \"error\"));\r\n    stream2.once(\"close\", websocket2.emitClose.bind(websocket2));\r\n  }\r\n}\r\nfunction sendAfterClose(websocket2, data, cb) {\r\n  if (data) {\r\n    const length = toBuffer(data).length;\r\n    if (websocket2._socket)\r\n      websocket2._sender._bufferedBytes += length;\r\n    else\r\n      websocket2._bufferedAmount += length;\r\n  }\r\n  if (cb) {\r\n    const err = new Error(\r\n      `WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`\r\n    );\r\n    process.nextTick(cb, err);\r\n  }\r\n}\r\nfunction receiverOnConclude(code, reason) {\r\n  const websocket2 = this[kWebSocket$1];\r\n  websocket2._closeFrameReceived = true;\r\n  websocket2._closeMessage = reason;\r\n  websocket2._closeCode = code;\r\n  if (websocket2._socket[kWebSocket$1] === void 0)\r\n    return;\r\n  websocket2._socket.removeListener(\"data\", socketOnData);\r\n  process.nextTick(resume, websocket2._socket);\r\n  if (code === 1005)\r\n    websocket2.close();\r\n  else\r\n    websocket2.close(code, reason);\r\n}\r\nfunction receiverOnDrain() {\r\n  const websocket2 = this[kWebSocket$1];\r\n  if (!websocket2.isPaused)\r\n    websocket2._socket.resume();\r\n}\r\nfunction receiverOnError(err) {\r\n  const websocket2 = this[kWebSocket$1];\r\n  if (websocket2._socket[kWebSocket$1] !== void 0) {\r\n    websocket2._socket.removeListener(\"data\", socketOnData);\r\n    process.nextTick(resume, websocket2._socket);\r\n    websocket2.close(err[kStatusCode]);\r\n  }\r\n  websocket2.emit(\"error\", err);\r\n}\r\nfunction receiverOnFinish() {\r\n  this[kWebSocket$1].emitClose();\r\n}\r\nfunction receiverOnMessage(data, isBinary) {\r\n  this[kWebSocket$1].emit(\"message\", data, isBinary);\r\n}\r\nfunction receiverOnPing(data) {\r\n  const websocket2 = this[kWebSocket$1];\r\n  websocket2.pong(data, !websocket2._isServer, NOOP);\r\n  websocket2.emit(\"ping\", data);\r\n}\r\nfunction receiverOnPong(data) {\r\n  this[kWebSocket$1].emit(\"pong\", data);\r\n}\r\nfunction resume(stream2) {\r\n  stream2.resume();\r\n}\r\nfunction socketOnClose() {\r\n  const websocket2 = this[kWebSocket$1];\r\n  this.removeListener(\"close\", socketOnClose);\r\n  this.removeListener(\"data\", socketOnData);\r\n  this.removeListener(\"end\", socketOnEnd);\r\n  websocket2._readyState = WebSocket$1.CLOSING;\r\n  let chunk;\r\n  if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {\r\n    websocket2._receiver.write(chunk);\r\n  }\r\n  websocket2._receiver.end();\r\n  this[kWebSocket$1] = void 0;\r\n  clearTimeout(websocket2._closeTimer);\r\n  if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {\r\n    websocket2.emitClose();\r\n  } else {\r\n    websocket2._receiver.on(\"error\", receiverOnFinish);\r\n    websocket2._receiver.on(\"finish\", receiverOnFinish);\r\n  }\r\n}\r\nfunction socketOnData(chunk) {\r\n  if (!this[kWebSocket$1]._receiver.write(chunk)) {\r\n    this.pause();\r\n  }\r\n}\r\nfunction socketOnEnd() {\r\n  const websocket2 = this[kWebSocket$1];\r\n  websocket2._readyState = WebSocket$1.CLOSING;\r\n  websocket2._receiver.end();\r\n  this.end();\r\n}\r\nfunction socketOnError$1() {\r\n  const websocket2 = this[kWebSocket$1];\r\n  this.removeListener(\"error\", socketOnError$1);\r\n  this.on(\"error\", NOOP);\r\n  if (websocket2) {\r\n    websocket2._readyState = WebSocket$1.CLOSING;\r\n    this.destroy();\r\n  }\r\n}\r\nconst WebSocket$2 = /* @__PURE__ */ getDefaultExportFromCjs(websocket);\r\nconst { tokenChars } = validationExports;\r\nfunction parse(header) {\r\n  const protocols = /* @__PURE__ */ new Set();\r\n  let start = -1;\r\n  let end = -1;\r\n  let i = 0;\r\n  for (i; i < header.length; i++) {\r\n    const code = header.charCodeAt(i);\r\n    if (end === -1 && tokenChars[code] === 1) {\r\n      if (start === -1)\r\n        start = i;\r\n    } else if (i !== 0 && (code === 32 || code === 9)) {\r\n      if (end === -1 && start !== -1)\r\n        end = i;\r\n    } else if (code === 44) {\r\n      if (start === -1) {\r\n        throw new SyntaxError(`Unexpected character at index ${i}`);\r\n      }\r\n      if (end === -1)\r\n        end = i;\r\n      const protocol2 = header.slice(start, end);\r\n      if (protocols.has(protocol2)) {\r\n        throw new SyntaxError(`The \"${protocol2}\" subprotocol is duplicated`);\r\n      }\r\n      protocols.add(protocol2);\r\n      start = end = -1;\r\n    } else {\r\n      throw new SyntaxError(`Unexpected character at index ${i}`);\r\n    }\r\n  }\r\n  if (start === -1 || end !== -1) {\r\n    throw new SyntaxError(\"Unexpected end of input\");\r\n  }\r\n  const protocol = header.slice(start, i);\r\n  if (protocols.has(protocol)) {\r\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\r\n  }\r\n  protocols.add(protocol);\r\n  return protocols;\r\n}\r\nvar subprotocol$1 = { parse };\r\nconst EventEmitter = require$$0$3;\r\nconst http = require$$2;\r\nconst { createHash } = require$$5;\r\nconst extension = extension$1;\r\nconst PerMessageDeflate2 = permessageDeflate;\r\nconst subprotocol = subprotocol$1;\r\nconst WebSocket2 = websocket;\r\nconst { GUID, kWebSocket } = constants;\r\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\r\nconst RUNNING = 0;\r\nconst CLOSING = 1;\r\nconst CLOSED = 2;\r\nclass WebSocketServer extends EventEmitter {\r\n  /**\r\n   * Create a `WebSocketServer` instance.\r\n   *\r\n   * @param {Object} options Configuration options\r\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\r\n   *     pending connections\r\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\r\n   *     track clients\r\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\r\n   * @param {String} [options.host] The hostname where to bind the server\r\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\r\n   *     size\r\n   * @param {Boolean} [options.noServer=false] Enable no server mode\r\n   * @param {String} [options.path] Accept only connections matching this path\r\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\r\n   *     permessage-deflate\r\n   * @param {Number} [options.port] The port where to bind the server\r\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\r\n   *     server to use\r\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\r\n   *     not to skip UTF-8 validation for text and close messages\r\n   * @param {Function} [options.verifyClient] A hook to reject connections\r\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\r\n   *     class to use. It must be the `WebSocket` class or class that extends it\r\n   * @param {Function} [callback] A listener for the `listening` event\r\n   */\r\n  constructor(options, callback) {\r\n    super();\r\n    options = {\r\n      maxPayload: 100 * 1024 * 1024,\r\n      skipUTF8Validation: false,\r\n      perMessageDeflate: false,\r\n      handleProtocols: null,\r\n      clientTracking: true,\r\n      verifyClient: null,\r\n      noServer: false,\r\n      backlog: null,\r\n      // use default (511 as implemented in net.js)\r\n      server: null,\r\n      host: null,\r\n      path: null,\r\n      port: null,\r\n      WebSocket: WebSocket2,\r\n      ...options\r\n    };\r\n    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\r\n      throw new TypeError(\r\n        'One and only one of the \"port\", \"server\", or \"noServer\" options must be specified'\r\n      );\r\n    }\r\n    if (options.port != null) {\r\n      this._server = http.createServer((req, res) => {\r\n        const body = http.STATUS_CODES[426];\r\n        res.writeHead(426, {\r\n          \"Content-Length\": body.length,\r\n          \"Content-Type\": \"text/plain\"\r\n        });\r\n        res.end(body);\r\n      });\r\n      this._server.listen(\r\n        options.port,\r\n        options.host,\r\n        options.backlog,\r\n        callback\r\n      );\r\n    } else if (options.server) {\r\n      this._server = options.server;\r\n    }\r\n    if (this._server) {\r\n      const emitConnection = this.emit.bind(this, \"connection\");\r\n      this._removeListeners = addListeners(this._server, {\r\n        listening: this.emit.bind(this, \"listening\"),\r\n        error: this.emit.bind(this, \"error\"),\r\n        upgrade: (req, socket, head) => {\r\n          this.handleUpgrade(req, socket, head, emitConnection);\r\n        }\r\n      });\r\n    }\r\n    if (options.perMessageDeflate === true)\r\n      options.perMessageDeflate = {};\r\n    if (options.clientTracking) {\r\n      this.clients = /* @__PURE__ */ new Set();\r\n      this._shouldEmitClose = false;\r\n    }\r\n    this.options = options;\r\n    this._state = RUNNING;\r\n  }\r\n  /**\r\n   * Returns the bound address, the address family name, and port of the server\r\n   * as reported by the operating system if listening on an IP socket.\r\n   * If the server is listening on a pipe or UNIX domain socket, the name is\r\n   * returned as a string.\r\n   *\r\n   * @return {(Object|String|null)} The address of the server\r\n   * @public\r\n   */\r\n  address() {\r\n    if (this.options.noServer) {\r\n      throw new Error('The server is operating in \"noServer\" mode');\r\n    }\r\n    if (!this._server)\r\n      return null;\r\n    return this._server.address();\r\n  }\r\n  /**\r\n   * Stop the server from accepting new connections and emit the `'close'` event\r\n   * when all existing connections are closed.\r\n   *\r\n   * @param {Function} [cb] A one-time listener for the `'close'` event\r\n   * @public\r\n   */\r\n  close(cb) {\r\n    if (this._state === CLOSED) {\r\n      if (cb) {\r\n        this.once(\"close\", () => {\r\n          cb(new Error(\"The server is not running\"));\r\n        });\r\n      }\r\n      process.nextTick(emitClose, this);\r\n      return;\r\n    }\r\n    if (cb)\r\n      this.once(\"close\", cb);\r\n    if (this._state === CLOSING)\r\n      return;\r\n    this._state = CLOSING;\r\n    if (this.options.noServer || this.options.server) {\r\n      if (this._server) {\r\n        this._removeListeners();\r\n        this._removeListeners = this._server = null;\r\n      }\r\n      if (this.clients) {\r\n        if (!this.clients.size) {\r\n          process.nextTick(emitClose, this);\r\n        } else {\r\n          this._shouldEmitClose = true;\r\n        }\r\n      } else {\r\n        process.nextTick(emitClose, this);\r\n      }\r\n    } else {\r\n      const server = this._server;\r\n      this._removeListeners();\r\n      this._removeListeners = this._server = null;\r\n      server.close(() => {\r\n        emitClose(this);\r\n      });\r\n    }\r\n  }\r\n  /**\r\n   * See if a given request should be handled by this server instance.\r\n   *\r\n   * @param {http.IncomingMessage} req Request object to inspect\r\n   * @return {Boolean} `true` if the request is valid, else `false`\r\n   * @public\r\n   */\r\n  shouldHandle(req) {\r\n    if (this.options.path) {\r\n      const index = req.url.indexOf(\"?\");\r\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\r\n      if (pathname !== this.options.path)\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Handle a HTTP Upgrade request.\r\n   *\r\n   * @param {http.IncomingMessage} req The request object\r\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\r\n   *     server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Function} cb Callback\r\n   * @public\r\n   */\r\n  handleUpgrade(req, socket, head, cb) {\r\n    socket.on(\"error\", socketOnError);\r\n    const key = req.headers[\"sec-websocket-key\"];\r\n    const version = +req.headers[\"sec-websocket-version\"];\r\n    if (req.method !== \"GET\") {\r\n      const message = \"Invalid HTTP method\";\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\r\n      return;\r\n    }\r\n    if (req.headers.upgrade.toLowerCase() !== \"websocket\") {\r\n      const message = \"Invalid Upgrade header\";\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n    if (!key || !keyRegex.test(key)) {\r\n      const message = \"Missing or invalid Sec-WebSocket-Key header\";\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n    if (version !== 8 && version !== 13) {\r\n      const message = \"Missing or invalid Sec-WebSocket-Version header\";\r\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n      return;\r\n    }\r\n    if (!this.shouldHandle(req)) {\r\n      abortHandshake(socket, 400);\r\n      return;\r\n    }\r\n    const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\r\n    let protocols = /* @__PURE__ */ new Set();\r\n    if (secWebSocketProtocol !== void 0) {\r\n      try {\r\n        protocols = subprotocol.parse(secWebSocketProtocol);\r\n      } catch (err) {\r\n        const message = \"Invalid Sec-WebSocket-Protocol header\";\r\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n        return;\r\n      }\r\n    }\r\n    const secWebSocketExtensions = req.headers[\"sec-websocket-extensions\"];\r\n    const extensions = {};\r\n    if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {\r\n      const perMessageDeflate = new PerMessageDeflate2(\r\n        this.options.perMessageDeflate,\r\n        true,\r\n        this.options.maxPayload\r\n      );\r\n      try {\r\n        const offers = extension.parse(secWebSocketExtensions);\r\n        if (offers[PerMessageDeflate2.extensionName]) {\r\n          perMessageDeflate.accept(offers[PerMessageDeflate2.extensionName]);\r\n          extensions[PerMessageDeflate2.extensionName] = perMessageDeflate;\r\n        }\r\n      } catch (err) {\r\n        const message = \"Invalid or unacceptable Sec-WebSocket-Extensions header\";\r\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\r\n        return;\r\n      }\r\n    }\r\n    if (this.options.verifyClient) {\r\n      const info = {\r\n        origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\r\n        secure: !!(req.socket.authorized || req.socket.encrypted),\r\n        req\r\n      };\r\n      if (this.options.verifyClient.length === 2) {\r\n        this.options.verifyClient(info, (verified, code, message, headers) => {\r\n          if (!verified) {\r\n            return abortHandshake(socket, code || 401, message, headers);\r\n          }\r\n          this.completeUpgrade(\r\n            extensions,\r\n            key,\r\n            protocols,\r\n            req,\r\n            socket,\r\n            head,\r\n            cb\r\n          );\r\n        });\r\n        return;\r\n      }\r\n      if (!this.options.verifyClient(info))\r\n        return abortHandshake(socket, 401);\r\n    }\r\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\r\n  }\r\n  /**\r\n   * Upgrade the connection to WebSocket.\r\n   *\r\n   * @param {Object} extensions The accepted extensions\r\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\r\n   * @param {Set} protocols The subprotocols\r\n   * @param {http.IncomingMessage} req The request object\r\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\r\n   *     server and client\r\n   * @param {Buffer} head The first packet of the upgraded stream\r\n   * @param {Function} cb Callback\r\n   * @throws {Error} If called more than once with the same socket\r\n   * @private\r\n   */\r\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\r\n    if (!socket.readable || !socket.writable)\r\n      return socket.destroy();\r\n    if (socket[kWebSocket]) {\r\n      throw new Error(\r\n        \"server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration\"\r\n      );\r\n    }\r\n    if (this._state > RUNNING)\r\n      return abortHandshake(socket, 503);\r\n    const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\r\n    const headers = [\r\n      \"HTTP/1.1 101 Switching Protocols\",\r\n      \"Upgrade: websocket\",\r\n      \"Connection: Upgrade\",\r\n      `Sec-WebSocket-Accept: ${digest}`\r\n    ];\r\n    const ws = new this.options.WebSocket(null);\r\n    if (protocols.size) {\r\n      const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\r\n      if (protocol) {\r\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\r\n        ws._protocol = protocol;\r\n      }\r\n    }\r\n    if (extensions[PerMessageDeflate2.extensionName]) {\r\n      const params = extensions[PerMessageDeflate2.extensionName].params;\r\n      const value = extension.format({\r\n        [PerMessageDeflate2.extensionName]: [params]\r\n      });\r\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\r\n      ws._extensions = extensions;\r\n    }\r\n    this.emit(\"headers\", headers, req);\r\n    socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\r\n    socket.removeListener(\"error\", socketOnError);\r\n    ws.setSocket(socket, head, {\r\n      maxPayload: this.options.maxPayload,\r\n      skipUTF8Validation: this.options.skipUTF8Validation\r\n    });\r\n    if (this.clients) {\r\n      this.clients.add(ws);\r\n      ws.on(\"close\", () => {\r\n        this.clients.delete(ws);\r\n        if (this._shouldEmitClose && !this.clients.size) {\r\n          process.nextTick(emitClose, this);\r\n        }\r\n      });\r\n    }\r\n    cb(ws, req);\r\n  }\r\n}\r\nvar websocketServer = WebSocketServer;\r\nfunction addListeners(server, map) {\r\n  for (const event of Object.keys(map))\r\n    server.on(event, map[event]);\r\n  return function removeListeners() {\r\n    for (const event of Object.keys(map)) {\r\n      server.removeListener(event, map[event]);\r\n    }\r\n  };\r\n}\r\nfunction emitClose(server) {\r\n  server._state = CLOSED;\r\n  server.emit(\"close\");\r\n}\r\nfunction socketOnError() {\r\n  this.destroy();\r\n}\r\nfunction abortHandshake(socket, code, message, headers) {\r\n  message = message || http.STATUS_CODES[code];\r\n  headers = {\r\n    Connection: \"close\",\r\n    \"Content-Type\": \"text/html\",\r\n    \"Content-Length\": Buffer.byteLength(message),\r\n    ...headers\r\n  };\r\n  socket.once(\"finish\", socket.destroy);\r\n  socket.end(\r\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(\"\\r\\n\") + \"\\r\\n\\r\\n\" + message\r\n  );\r\n}\r\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\r\n  if (server.listenerCount(\"wsClientError\")) {\r\n    const err = new Error(message);\r\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\r\n    server.emit(\"wsClientError\", err, socket, req);\r\n  } else {\r\n    abortHandshake(socket, code, message);\r\n  }\r\n}\r\nconst websocketServer$1 = /* @__PURE__ */ getDefaultExportFromCjs(websocketServer);\r\nexport {\r\n  receiver$1 as Receiver,\r\n  sender$1 as Sender,\r\n  WebSocket$2 as WebSocket,\r\n  websocketServer$1 as WebSocketServer,\r\n  stream$1 as createWebSocketStream,\r\n  WebSocket$2 as default\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}